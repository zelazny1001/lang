function processTranscriptionFile(fileContent) {
    const groundTruthFileName = getGroundTruthFileName();
    if (!groundTruthFileName) {
        alert("Ground Truth filename not found. Please load a Ground Truth file first.");
        return;
    }

    const key = extractGroundTruthKey(groundTruthFileName);
    if (!key) {
        alert("Unable to extract key from Ground Truth filename.");
        return;
    }

    const rows = parsePipeSeparatedFile(fileContent);
    const filteredRows = filterAndSortRows(rows, key);

    cachedTranscriptionData = filteredRows;
    const transcripts = filteredRows.map(row => row.transcript).join("\n");
    populateTextArea("transcription", transcripts);
}

function getGroundTruthFileName() {
    const fileInput = document.getElementById("groundTruthFileInput");
    return fileInput.files[0]?.name || null;
}

function extractGroundTruthKey(filename) {
    const match = filename.match(/ground_truth_(.*?)\./);
    return match ? match[1] : null;
}

function parsePipeSeparatedFile(content) {
    const lines = content.split("\n").filter(line => line.trim() !== "");
    const headers = lines[0].split("|").map(header => header.trim());
    const rows = lines.slice(1).map(line => {
        const values = line.split("|").map(value => value.trim());
        const row = {};
        headers.forEach((header, index) => {
            row[header] = values[index];
        });

        row.seqNum = parseInt(row.seqNum, 10);
        row.start = parseInt(row.start, 10);
        row.end = parseInt(row.end, 10);
        row.samples = parseInt(row.samples, 10);
        row.tokens = parseInt(row.tokens, 10);
        return row;
    });
    return rows;
}

function filterAndSortRows(rows, key) {
    return rows
        .filter(row => row.filename.includes(key))
        .sort((a, b) => a.seqNum - b.seqNum);
}