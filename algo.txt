package transcriptionviewer;

public class CallViewConfig {
    public static final int SECONDS_PER_BLOCK = 1;
    public static final int CELLS_PER_BLOCK = SECONDS_PER_BLOCK * 1000 / 20;
    public static final int BLOCKS_PER_ROW = 3;
    public static final int CELLS_PER_ROW = (BLOCKS_PER_ROW * CELLS_PER_BLOCK) + (BLOCKS_PER_ROW - 1);
    public static final int CELL_WIDTH = 1;
    public static final int CELL_HEIGHT = 10;
    public static final int SUMMARY_CELL_WIDTH = 2;
    public static final int SUMMARY_CELL_HEIGHT = 15;
    public static final int SUMMARY_COLUMNS = 250;
    public static final int TICK_INTERVAL_SECONDS = 3;
    public static final double SECONDS_PER_SAMPLE = 0.02;
}

-----------------------------------------------------------------------------

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.List;

@RestController
public class CallViewController {

    private String mostRecentCallID = "most recent";
    private List<Boolean> boolData;

    @GetMapping("/viewcall")
    public String displayBoolGrid() {
        return generateHtmlContent(boolData);
    }

    public String generateHtmlContent(List<Boolean> boolData) {
        double totalDurationSeconds = boolData.size() * CallViewConfig.SECONDS_PER_SAMPLE;
        return new StringBuilder().append(generateHtmlHeader()).append("<body>")
                .append("<h2>Summary for call: ").append(mostRecentCallID + "</h2>").append(generateSummaryTable(boolData))
                .append("<br/><br/>").append(generateRulerTable(boolData, totalDurationSeconds))
                .append("<br/><br/>").append("<h2>Detail</h2>").append(generateDetailTable(boolData))
                .append("</body></html>").toString();
    }

    private String generateHtmlHeader() {
        return new StringBuilder("<html><head>").append("<style>")
                .append("table { border-collapse: collapse; width: 100%; table-layout: fixed;}")
                .append("td { width: ").append(CallViewConfig.CELL_WIDTH).append("px; height: ").append(CallViewConfig.CELL_HEIGHT).append("px; border: 1px solid gray; }")
                .append(".summary-cell { width: ").append(CallViewConfig.SUMMARY_CELL_WIDTH).append("px; height: ").append(CallViewConfig.SUMMARY_CELL_HEIGHT).append("px; border: none; }")
                .append(".green { background-color: green; }").append(".red { background-color: red; }")
                .append(".white { background-color: white; }").append("h2 { font-family: Arial; font-weight: bold; font-size: 14px; }")
                .append(".ruler-cell { font-family: Arial; font-size: 10px; text-align: center; border-top: 1px solid gray; border-bottom: 1px solid gray; border-left: none; border-right: none; }")
                .append(".ruler-transition { border-left: 1px solid black; }").append(".ruler-time { font-family: Arial; font-size: 10px; text-align: center; border-top: 1px solid gray; border-bottom: 1px solid gray; border-left: 1px solid lightgray; border-right: none; }")
                .append("</style></head>").toString();
    }

    private String generateMouseOver(String value) {
        return "title='" + value + "'";
    }

    private String generateSummaryTable(List<Boolean> boolData) {
        return new StringBuilder("<table><tr>").append(generateSummaryRow(boolData)).append("</tr></table>").toString();
    }

    private String generateSummaryRow(List<Boolean> boolData) {
        StringBuilder summaryRow = new StringBuilder();
        List<Integer> blockSizes = new ArrayList<>();
        List<Boolean> blockTypes = new ArrayList<>();
        boolean currentType = boolData.get(0);
        int currentBlockSize = 0;

        for (Boolean cell : boolData) {
            if (cell == currentType) currentBlockSize++;
            else {
                blockSizes.add(currentBlockSize);
                blockTypes.add(currentType);
                currentType = cell;
                currentBlockSize = 1;
            }
        }

        blockSizes.add(currentBlockSize);
        blockTypes.add(currentType);
        int totalCells = boolData.size();
        double accumulatedTime = 0.0;
        double timePerColumn = CallViewConfig.SECONDS_PER_SAMPLE * totalCells / CallViewConfig.SUMMARY_COLUMNS;

        for (int i = 0; i < blockSizes.size(); i++) {
            int scaledSize = (int) Math.round((double) blockSizes.get(i) / totalCells * CallViewConfig.SUMMARY_COLUMNS);

            for (int j = 0; j < scaledSize; j++) {
                String timeInfo = "Time: " + String.format("%.2f", accumulatedTime) + " seconds";

                if (blockTypes.get(i)) {
                    summaryRow.append("<td class='summary-cell green' ")
                            .append(generateMouseOver(timeInfo))
                            .append(">");
                } else {
                    summaryRow.append("<td class='summary-cell red' ")
                            .append(generateMouseOver(timeInfo))
                            .append(">");
                }

                accumulatedTime += timePerColumn;
            }
        }

        return summaryRow.toString();
    }

    private String generateRulerTable(List<Boolean> boolData, double totalDurationSeconds) {
        return new StringBuilder("<table><tr>").append(generateRulerRow(boolData, totalDurationSeconds)).append("</tr></table>").toString();
    }

    private String generateRulerRow(List<Boolean> boolData, double totalDurationSeconds) {
        StringBuilder rulerRow = new StringBuilder();
        List<Integer> blockSizes = new ArrayList<>();
        List<Boolean> blockTypes = new ArrayList<>();
        boolean currentType = boolData.get(0);
        int currentBlockSize = 0;

        for (Boolean cell : boolData) {
            if (cell == currentType) currentBlockSize++;
            else {
                blockSizes.add(currentBlockSize);
                blockTypes.add(currentType);
                currentType = cell;
                currentBlockSize = 1;
            }
        }

        blockSizes.add(currentBlockSize);
        blockTypes.add(currentType);
        double timePerColumn = totalDurationSeconds / CallViewConfig.SUMMARY_COLUMNS;
        double accumulatedTime = 0.0;
        double nextTickMark = CallViewConfig.TICK_INTERVAL_SECONDS;

        for (int i = 0; i < blockSizes.size(); i++) {
            int scaledSize = (int) Math.round((double) blockSizes.get(i) / boolData.size() * CallViewConfig.SUMMARY_COLUMNS);
            for (int j = 0; j < scaledSize; j++) {
                boolean isTransition = (j == 0 && i > 0);
                if (accumulatedTime >= nextTickMark) {
                    rulerRow.append("<td class='ruler-time'>").append((int) nextTickMark).append("</td>");
                    nextTickMark += CallViewConfig.TICK_INTERVAL_SECONDS;
                } else {
                    rulerRow.append("<td class='ruler-cell ").append(isTransition ? "ruler-transition" : "").append("'></td>");
                }
                accumulatedTime += timePerColumn;
            }
        }

        return rulerRow.toString();
    }

    private String generateDetailTable(List<Boolean> boolData) {
        StringBuilder detailTable = new StringBuilder("<table>");
        int cellCounter = 0, blockCounter = 0, blocksInCurrentRow = 0;

        for (int i = 0; i < boolData.size(); i++) {
            if (cellCounter == 0) detailTable.append("<tr>");

            String cellInfo = "Packet: " + (i + 1) + ", Time: " + String.format("%.2f", (i + 1) * CallViewConfig.SECONDS_PER_SAMPLE) + " seconds";

            if (boolData.get(i)) {
                detailTable.append("<td class='green' ")
                        .append(generateMouseOver(cellInfo))
                        .append(">");
            } else {
                detailTable.append("<td class='red' ")
                        .append(generateMouseOver(cellInfo))
                        .append(">");
            }

            cellCounter++;
            blockCounter++;

            if (blockCounter == CallViewConfig.CELLS_PER_BLOCK) {
                blocksInCurrentRow++;
                if (blocksInCurrentRow < CallViewConfig.BLOCKS_PER_ROW) {
                    detailTable.append("<td class='white'></td>");
                    cellCounter++;
                }
                blockCounter = 0;
            }

            if (cellCounter == CallViewConfig.CELLS_PER_ROW) {
                detailTable.append("</tr>");
                cellCounter = 0;
                blocksInCurrentRow = 0;
            }
        }

        if (cellCounter > 0) detailTable.append("</tr>");
        detailTable.append("</table>");
        return detailTable.toString();
    }

    public String getMostRecentCallID() {
        return mostRecentCallID;
    }

    public void setMostRecentCallID(String mostRecentCallID) {
        this.mostRecentCallID = mostRecentCallID;
    }

    public List<Boolean> getBoolData() {
        return boolData;
    }

    public void setBoolData(List<Boolean> boolData) {
        this.boolData = boolData;
    }
}

---------------------------------------------------------------------------

import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class CallViewControllerTest {

    public static final String docRoot = "j:/tmp/transcript-viewer/";

    @Test
    public void testGenerateHtmlTable() throws IOException {
        List<Boolean> testData = BoolListGenerator.generateTestBoolsFromSeconds(2.5, 4.1, 1.6, 8.5, 10.04, 5.33, 15.7, 6.5, 12);

        CallViewController controller = new CallViewController();
        controller.setBoolData(testData);
        controller.setMostRecentCallID("1234-5678-0987-4321");
        String htmlContent = controller.displayBoolGrid();

        Path filePath = saveHtmlToFile(docRoot, "table-bool.html", htmlContent);

        assertTrue(Files.exists(filePath));
        assertTrue(Files.size(filePath) > 0);

        int expectedGreenCount = (int) testData.stream().filter(b -> b).count();
        int expectedRedCount = (int) testData.stream().filter(b -> !b).count();

        // Use regex to count occurrences of 'green' and 'red' classes
        int actualGreenCount = countOccurrencesWithRegex(htmlContent, "class='green'");
        int actualRedCount = countOccurrencesWithRegex(htmlContent, "class='red'");

        assertEquals(expectedGreenCount, actualGreenCount);
        assertEquals(expectedRedCount, actualRedCount);
    }

    @Test
    public void testGenerateTestBoolsFromSeconds() {
        List<Boolean> result = BoolListGenerator.generateTestBoolsFromSeconds(2, 3, 1, 4);
        List<Boolean> expected = BoolListGenerator.generateTestBools(100, 150, 50, 200);
        assertEquals(expected, result);
    }

    private Path saveHtmlToFile(String directory, String fileName, String content) throws IOException {
        Path directoryPath = Paths.get(directory);
        Path filePath = directoryPath.resolve(fileName);

        Files.createDirectories(directoryPath);
        Files.write(filePath, content.getBytes());

        return filePath;
    }

    private int countOccurrencesWithRegex(String content, String pattern) {
        Matcher matcher = Pattern.compile(pattern).matcher(content);
        int count = 0;
        while (matcher.find()) {
            count++;
        }
        return count;
    }
}