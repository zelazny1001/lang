<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cosine Similarity Heatmap Table</title>
  <style>
    table {
      border-collapse: collapse;
      margin: 20px;
      font-family: Arial, sans-serif;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 5px;
      text-align: center;
      width: 20px;
      height: 20px;
    }
    th {
      background-color: #f0f0f0;
      position: sticky;
      top: 0;
    }
    .tooltip {
      position: absolute;
      display: none;
      background-color: #333;
      color: #fff;
      padding: 4px;
      border-radius: 3px;
      font-size: 12px;
    }
  </style>
</head>
<body>

<h3>Select CSV File</h3>
<input type="file" id="fileInput" accept=".csv" />
<div id="heatmap-table"></div>
<div id="legend"></div>
<div class="tooltip" id="tooltip"></div>

<script>
// Helper function to parse CSV data
function parseCSV(text) {
  const rows = text.trim().split('\n').map(row => row.split(','));
  const headers = rows[0];
  const data = rows.slice(1).map(row => {
    return {
      call_chunk1: row[0],
      call_chunk2: row[1],
      similarity: parseFloat(row[2])
    };
  });
  return { headers, data };
}

// Natural sort comparator for labels like "357_2" to appear before "357_10"
function naturalSort(a, b) {
  return a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
}

// Function to generate color based on similarity value
function getColor(value) {
  const red = Math.round((1 - value) * 128 + 127);
  const blue = Math.round((1 + value) * 128 - 127);
  return `rgb(${red}, 128, ${blue})`;
}

// Event listener for file input
document.getElementById('fileInput').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    const csvText = e.target.result;
    const { data } = parseCSV(csvText);

    // Extract unique call chunk labels and sort them using natural order
    const callChunks = Array.from(new Set(data.map(d => d.call_chunk1).concat(data.map(d => d.call_chunk2)))).sort(naturalSort);

    // Map each call chunk to an index
    const chunkIndex = {};
    callChunks.forEach((chunk, i) => chunkIndex[chunk] = i);

    // Initialize a matrix with NaN values for missing data
    const matrix = Array.from({ length: callChunks.length }, () => Array(callChunks.length).fill(NaN));

    // Populate the matrix with similarity scores, set diagonal to 1 for self-similarity
    data.forEach(d => {
      const rowIndex = chunkIndex[d.call_chunk1];
      const colIndex = chunkIndex[d.call_chunk2];
      matrix[rowIndex][colIndex] = d.similarity;
    });
    callChunks.forEach((_, i) => matrix[i][i] = 1);

    // Generate the HTML table
    const table = document.createElement('table');
    const headerRow = document.createElement('tr');

    // Add an empty top-left corner cell
    const topLeftCell = document.createElement('th');
    headerRow.appendChild(topLeftCell);

    // Add column headers
    callChunks.forEach(chunk => {
      const th = document.createElement('th');
      th.textContent = chunk;
      headerRow.appendChild(th);
    });
    table.appendChild(headerRow);

    // Tooltip setup
    const tooltip = document.getElementById('tooltip');
    function showTooltip(event, text) {
      tooltip.style.display = 'block';
      tooltip.style.left = event.pageX + 10 + 'px';
      tooltip.style.top = event.pageY + 10 + 'px';
      tooltip.textContent = text;
    }
    function hideTooltip() {
      tooltip.style.display = 'none';
    }

    // Add rows with row headers and similarity cells
    callChunks.forEach((chunk1, rowIndex) => {
      const row = document.createElement('tr');
      const rowHeader = document.createElement('th');
      rowHeader.textContent = chunk1;
      row.appendChild(rowHeader);

      callChunks.forEach((chunk2, colIndex) => {
        const cell = document.createElement('td');
        const similarity = matrix[rowIndex][colIndex];
        cell.textContent = isNaN(similarity) ? "" : similarity.toFixed(2);
        cell.style.backgroundColor = isNaN(similarity) ? "#f9f9f9" : getColor(similarity);

        // Tooltip interaction
        cell.addEventListener('mouseover', (event) => {
          if (!isNaN(similarity)) showTooltip(event, `Similarity: ${similarity.toFixed(2)}`);
        });
        cell.addEventListener('mouseout', hideTooltip);

        row.appendChild(cell);
      });

      table.appendChild(row);
    });

    // Display the table
    const heatmapContainer = document.getElementById('heatmap-table');
    heatmapContainer.innerHTML = "";  // Clear previous table if any
    heatmapContainer.appendChild(table);

    // Create a color legend
    createLegend();
  };

  reader.readAsText(file);
});

// Create a legend for color scale
function createLegend() {
  const legend = document.getElementById('legend');
  legend.innerHTML = '<h4>Cosine Similarity Legend</h4>';
  for (let i = -1; i <= 1; i += 0.2) {
    const colorBox = document.createElement('span');
    colorBox.style.display = 'inline-block';
    colorBox.style.width = '20px';
    colorBox.style.height = '20px';
    colorBox.style.backgroundColor = getColor(i);
    legend.appendChild(colorBox);
  }
  legend.innerHTML += '<br>-1 &nbsp;&nbsp;&nbsp;&nbsp; 0 &nbsp;&nbsp;&nbsp;&nbsp; 1';
}
</script>

</body>
</html>