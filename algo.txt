import org.jtransforms.fft.FloatFFT_1D;
import java.util.ArrayList;
import java.util.List;

public class SpanDetector {
    private int sr;
    private int currIdx;
    private Candidate currCandidate;
    private List<Span> spans;
    private float backgroundEnergyTimeout;
    private boolean backgroundEnergyInitialized;
    private float backgroundEnergy;
    private float dbOffset;
    private float minSoFar;

    public SpanDetector(int sr) {
        this.sr = sr;
        this.currIdx = 0;
        this.currCandidate = null;
        this.spans = new ArrayList<>();
        this.backgroundEnergyTimeout = 2.0f;
        this.backgroundEnergyInitialized = false;
        this.backgroundEnergy = 0.0f;
        this.dbOffset = 2.5f;
        this.minSoFar = Float.POSITIVE_INFINITY;
    }

    public List<Span> addToStream(float[] audio, String speaker) {
        int nSamples = audio.length;
        float secondsPerFrame = 20e-3f;
        int samplesPerFrame = (int) (secondsPerFrame * sr);
        List<Span> spans = new ArrayList<>();

        for (int i = 0; i < nSamples - 1; i += samplesPerFrame) {
            int start = i + currIdx;
            int end = start + samplesPerFrame;
            float[] audioB = new float[samplesPerFrame];
            System.arraycopy(audio, i, audioB, 0, samplesPerFrame);

            float frameEnergy = calculateFrameEnergy(audioB);
            if (frameEnergy < minSoFar) {
                minSoFar = frameEnergy;
            }

            if ((float) currIdx / sr < backgroundEnergyTimeout) {
                if (!backgroundEnergyInitialized) {
                    backgroundEnergy = frameEnergy;
                    backgroundEnergyInitialized = true;
                } else {
                    backgroundEnergy += (frameEnergy - backgroundEnergy) / (end / samplesPerFrame);
                }
                continue;
            }

            float offset = (float) Math.log10(frameEnergy / backgroundEnergy);
            if (offset < 0) {
                backgroundEnergy = (0.1f * backgroundEnergy + 0.9f * frameEnergy);
                continue;
            } else if (offset > dbOffset) {
                if (offset > 5) {
                    backgroundEnergy = (0.98f * backgroundEnergy + 0.02f * frameEnergy);
                } else {
                    backgroundEnergy = (0.90f * backgroundEnergy + 0.10f * minSoFar);
                }
                if (currCandidate == null) {
                    currCandidate = new Candidate(start, frameEnergy);
                }
                Span span = new Span(currCandidate.getStartIdx(), end, currCandidate.getStartDb(), frameEnergy,
                        currCandidate.getNumVoiceChunks(), currCandidate.getNumNonVoiceChunks(), speaker);
                spans.add(span);
                this.spans.add(span);

                currCandidate = null;
            }
        }
        currIdx += nSamples;
        return spans;
    }

    private float calculateFrameEnergy(float[] audioB) {
        float[] fftResult = getFFT(audioB);
        float sumSquares = 0.0f;
        for (float v : fftResult) {
            sumSquares += v * v;
        }
        return sumSquares / fftResult.length;
    }

    private float[] getFFT(float[] audio) {
        int N = audio.length;
        float[] windowedAudio = new float[N];
        for (int i = 0; i < N; i++) {
            windowedAudio[i] = (float)(audio[i] * (0.54f - 0.46f * Math.cos(2 * Math.PI * i / (N - 1))));
        }

        FloatFFT_1D fft = new FloatFFT_1D(N);
        fft.realForward(windowedAudio);

        float[] result = new float[N / 2];
        result[0] = windowedAudio[0]; // DC component
        for (int i = 1; i < N / 2; i++) {
            result[i] = (float) Math.sqrt(windowedAudio[2 * i] * windowedAudio[2 * i] + windowedAudio[2 * i + 1] * windowedAudio[2 * i + 1]);
        }
        return result;
    }

    public static void main(String[] args) {
        SpanDetector detector = new SpanDetector(16000);
        float[] audio = { /* some audio data */ };
        String speaker = "speaker1";
        List<Span> spans = detector.addToStream(audio, speaker);
        // Process spans
    }
}