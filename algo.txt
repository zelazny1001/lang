import org.springframework.integration.aggregator.MessageGroupProcessor;
import org.springframework.integration.store.MessageGroup;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class PreVADMessageAggregator implements MessageGroupProcessor {

    @Override
    public Message<?> processMessageGroup(MessageGroup group) {
        List<Message<?>> messages = group.getMessages();
        String aggregatedPayload = messages.stream()
                .map(Message::getPayload)
                .map(Object::toString)
                .collect(Collectors.joining(";"));
        return MessageBuilder.withPayload(aggregatedPayload).build();
    }
}

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.integration.aggregator.AggregatingMessageHandler;
import org.springframework.integration.store.MessageGroupStore;
import org.springframework.integration.store.SimpleMessageStore;
import org.springframework.messaging.MessageHandler;

@Configuration
public class AggregationConfig {

    private int x = 3; //CCHAppResourceBundle.getIntegerProperty(DMLConstants.PRE_VAD_AGGREGATOR_SIZE);
    
    @Bean
    public MessageGroupStore messageStore() {
        return new SimpleMessageStore();
    }

    @Bean
    public MessageHandler aggregatingMessageHandler(PreVADMessageAggregator aggregator) {
        AggregatingMessageHandler handler = new AggregatingMessageHandler(aggregator, messageStore());
        handler.setCorrelationStrategy(message -> ((RTPPacket) message.getPayload()).ssrc);
        handler.setReleaseStrategy(group -> group.size() == x);
        return handler;
    }
}


=============================== SAMPLE ====================

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.integration.dsl.IntegrationFlow;
import org.springframework.integration.dsl.IntegrationFlows;
import org.springframework.integration.dsl.support.Transformers;
import org.springframework.messaging.MessageHandler;
import org.springframework.stereotype.Service;

@Service
public class IntegrationFlowService {

    @Autowired
    private MessageHandler aggregatingMessageHandler;

    @Value("${aggregation.group.size}")
    private int groupSize;

    public IntegrationFlow defineFlow() {
        return IntegrationFlows.from("inputChannel")
                .enrichHeaders(headers -> headers.header("correlationId", "fixedCorrelationId"))
                .transform(new RtpMessageTransformer())  // Assuming RtpMessageTransformer exists
                .filter(m -> m != null)
                .resequence(spec -> spec.correlationStrategy(m -> ((RTPPacket) m.getPayload()).getSsrc())
                                        .releaseStrategy(group -> group.size() == groupSize))
                .filter(m -> true)
                .handle(aggregatingMessageHandler)
                .handle((payload, headers) -> {
                    System.out.println("Aggregated payload: " + payload);
                    return null;
                })
                .get();
    }
}