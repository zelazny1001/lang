package analyzer;

import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import org.jtransforms.fft.FloatFFT_1D;

public class FFTAnalyzer {

    private final Map<String, byte[]> g711Cache = new HashMap<>();

    public static void main(String[] args) throws IOException {
        String transcriptionWindowsInputFilename = "/tmp/formatted-analysis.txt";
        String fftAnalysisOutputFilename = "/tmp/fft-analysis.txt";
        String g711InputFileRootDirectory = "/asr-data/rod-calls/";
        FFTAnalyzer analyzer = new FFTAnalyzer();
        analyzer.processData(transcriptionWindowsInputFilename, fftAnalysisOutputFilename, g711InputFileRootDirectory);
    }

    public void processData(String transcriptionWindowsInputFilename, String outputFilename, String g711InputFileRoot) throws IOException {
        List<TranscriptionWindow> transcriptionWindowRecords = ingestTranscriptionWindowDataFromFile(transcriptionWindowsInputFilename);
        writeFFTValuesToFile(outputFilename, g711InputFileRoot, transcriptionWindowRecords);
    }

    public void writeFFTValuesToFile(String outputFilename, String g711InputFileRoot, List<TranscriptionWindow> transcriptionWindowRecords) throws IOException {
        int totalRecords = transcriptionWindowRecords.size();
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFilename))) {
            for (int i = 0; i < totalRecords; i++) {
                TranscriptionWindow record = transcriptionWindowRecords.get(i);
                String filePath = g711InputFileRoot + record.getFilename() + ".raw";
                byte[] allG711Bytes = g711Cache.computeIfAbsent(filePath, this::readAllBytes);
                if (allG711Bytes == null) {
                    System.out.println("Failed to load G711 data for file: " + filePath);
                    continue;
                }
                int startIdx = record.getStart() - 1;
                int endIdx = record.getEnd() - 1;
                if (startIdx < 0 || endIdx >= allG711Bytes.length || startIdx > endIdx) {
                    System.out.println("Invalid start or end indices for file: " + filePath);
                    continue;
                }
                byte[] bytesBetweenStartAndEnd = new byte[endIdx - startIdx + 1];
                System.arraycopy(allG711Bytes, startIdx, bytesBetweenStartAndEnd, 0, bytesBetweenStartAndEnd.length);
                float[] floatsBetweenStartAndEnd = G711Codec.g711ByteArrayToNormalizedPCM(bytesBetweenStartAndEnd);
                float[] fftResult = FFTProcessor.getFFT(floatsBetweenStartAndEnd);
                writer.write(String.format("%s | %d | %d | %s%n", record.getFilename(), record.getStart(), record.getEnd(), record.getTranscript()));
                for (float fftValue : fftResult) {
                    writer.write(fftValue + System.lineSeparator());
                }
                System.out.printf("Processing %d/%d - File: %s | Input Floats: %d | FFT Values: %d%n",
                        i + 1, totalRecords, record.getFilename(), floatsBetweenStartAndEnd.length, fftResult.length);
            }
        }
    }

    private byte[] readAllBytes(String filePath) {
        try (InputStream inputStream = new FileInputStream(filePath)) {
            return G711Codec.readAllBytes(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    private List<TranscriptionWindow> ingestTranscriptionWindowDataFromFile(String path) throws IOException {
        return Files.lines(Paths.get(path))
                .skip(1)
                .map(line -> {
                    String[] parts = line.split("\\|");
                    return new TranscriptionWindow(
                            parts[0].trim(),                        // filename
                            Integer.parseInt(parts[2].trim()),      // seqNum
                            Integer.parseInt(parts[3].trim()),      // start
                            Integer.parseInt(parts[4].trim()),      // end
                            parts[5].trim(),                        // transcript
                            Integer.parseInt(parts[6].trim()),      // tokens
                            Integer.parseInt(parts[7].trim()),      // samples
                            Float.parseFloat(parts[8].trim())       // samplesPerToken
                    );
                })
                .collect(Collectors.toList());
    }
}