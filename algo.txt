let cachedTranscriptionContent = null;

document.getElementById("groundTruthFileInput").addEventListener("change", (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
        populateTextArea("groundTruth", reader.result);
        if (cachedTranscriptionContent) {
            processTranscriptionFile(cachedTranscriptionContent);
        }
    };
    reader.readAsText(file);
});

document.getElementById("transcriptionFileInput").addEventListener("change", (event) => {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
        cachedTranscriptionContent = reader.result;
        processTranscriptionFile(cachedTranscriptionContent);
    };
    reader.readAsText(file);
});

document.getElementById("compareButton").addEventListener("click", () => {
    const groundTruthDiv = document.getElementById("groundTruth");
    const transcriptionDiv = document.getElementById("transcription");

    const groundTruthText = groundTruthDiv.innerText.trim();
    const transcriptionText = transcriptionDiv.innerText.trim();

    const exclusionInput = document.getElementById("exclude").value;
    const exclusions = parseExclusions(exclusionInput);

    const preprocessedGroundTruth = preprocessText(groundTruthText, exclusions).split(/\s+/);
    const preprocessedTranscription = preprocessText(transcriptionText, exclusions).split(/\s+/);

    const { alignedGroundTruth, alignedTranscription } = alignTexts(preprocessedGroundTruth, preprocessedTranscription);

    groundTruthDiv.innerHTML = formatHighlightedText(alignedGroundTruth, alignedTranscription);
    transcriptionDiv.innerHTML = formatHighlightedText(alignedTranscription, alignedGroundTruth);

    const { wer, substitutions, deletions, insertions, total } = calculateWER(
        preprocessedGroundTruth.join(" "),
        preprocessedTranscription.join(" ")
    );

    document.getElementById("werField").value = `${wer}%`;
    document.getElementById("sField").value = substitutions;
    document.getElementById("dField").value = deletions;
    document.getElementById("iField").value = insertions;
    document.getElementById("nField").value = total;
});

document.getElementById("clearButton").addEventListener("click", () => {
    const groundTruthDiv = document.getElementById("groundTruth");
    const transcriptionDiv = document.getElementById("transcription");

    groundTruthDiv.innerText = groundTruthDiv.innerText;
    transcriptionDiv.innerText = transcriptionDiv.innerText;

    document.getElementById("werField").value = "";
    document.getElementById("sField").value = "";
    document.getElementById("dField").value = "";
    document.getElementById("iField").value = "";
    document.getElementById("nField").value = "";
});

function processTranscriptionFile(fileContent) {
    const groundTruthFileName = getGroundTruthFileName();
    if (!groundTruthFileName) {
        alert("Ground Truth filename not found. Please load a Ground Truth file first.");
        return;
    }

    const key = extractGroundTruthKey(groundTruthFileName);
    if (!key) {
        alert("Unable to extract key from Ground Truth filename.");
        return;
    }

    const rows = parsePipeSeparatedFile(fileContent);
    const filteredRows = filterAndSortRows(rows, key);
    const finalRows = applyAdditionalFilters(filteredRows);
    const transcripts = finalRows.map(row => row.transcript).join("\n");
    populateTextArea("transcription", transcripts);
}

function applyAdditionalFilters(rows) {
    return rows.filter(row => {
        const samples = parseInt(row.samples, 10);
        const tokens = parseInt(row.tokens, 10);
        return !(samples === 250 && tokens <= 2);
    });
}

function getGroundTruthFileName() {
    const fileInput = document.getElementById("groundTruthFileInput");
    return fileInput.files[0]?.name || null;
}

function extractGroundTruthKey(filename) {
    const match = filename.match(/ground_truth_(.*?)\./);
    return match ? match[1] : null;
}

function parsePipeSeparatedFile(content) {
    const lines = content.split("\n").filter(line => line.trim() !== "");
    const headers = lines[0].split("|").map(header => header.trim());
    const rows = lines.slice(1).map(line => {
        const values = line.split("|").map(value => value.trim());
        const row = {};
        headers.forEach((header, index) => {
            row[header] = values[index];
        });
        row.seqNum = parseInt(row.seqNum, 10);
        row.samples = parseInt(row.samples, 10);
        row.tokens = parseInt(row.tokens, 10);
        return row;
    });
    return rows;
}

function filterAndSortRows(rows, key) {
    return rows
        .filter(row => row.filename.includes(key))
        .sort((a, b) => a.seqNum - b.seqNum);
}

function populateTextArea(areaId, content) {
    const textArea = document.getElementById(areaId);
    textArea.innerText = content;
}

function preprocessText(text, exclusions) {
    text = text.replace(/\n+/g, " ");
    text = text.replace(/<.*?>/g, " ");
    text = text.replace(/[.,!?;]/g, " ").trim();
    exclusions.forEach(word => {
        const regex = new RegExp(`\\b${word}\\b`, "gi");
        text = text.replace(regex, " ");
    });
    return text.replace(/\s+/g, " ");
}

function parseExclusions(exclusionInput) {
    return exclusionInput.split('|').map(word => word.trim()).filter(word => word !== "");
}

function calculateWER(groundTruth, transcription) {
    const groundWords = groundTruth.split(/\s+/);
    const transcribedWords = transcription.split(/\s+/);
    const m = groundWords.length;
    const n = transcribedWords.length;
    
    // Create a DP table with dimensions (m+1)x(n+1)
    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));
    
    // Initialize edit distance matrix
    for (let i = 0; i <= m; i++) {
        dp[i][0] = i;
    }
    for (let j = 0; j <= n; j++) {
        dp[0][j] = j;
    }
    
    // Fill the DP table
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (groundWords[i - 1] === transcribedWords[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + Math.min(
                    dp[i - 1][j - 1],  // Replace
                    dp[i - 1][j],      // Delete
                    dp[i][j - 1]       // Insert
                );
            }
        }
    }
    
    // Enhanced backtracking to precisely count errors
    let i = m, j = n;
    let substitutions = 0, deletions = 0, insertions = 0;
    
    while (i > 0 || j > 0) {
        if (i > 0 && j > 0 && groundWords[i - 1] === transcribedWords[j - 1]) {
            // Correct match
            i--;
            j--;
        } else if (i > 0 && j > 0) {
            // Substitution
            if (dp[i][j] === dp[i-1][j-1] + 1) {
                substitutions++;
                i--;
                j--;
            }
            // Deletion
            else if (dp[i][j] === dp[i-1][j] + 1) {
                deletions++;
                i--;
            }
            // Insertion
            else if (dp[i][j] === dp[i][j-1] + 1) {
                insertions++;
                j--;
            }
        }
        // Handle remaining deletions
        else if (i > 0) {
            deletions++;
            i--;
        }
        // Handle remaining insertions
        else if (j > 0) {
            insertions++;
            j--;
        }
    }
    
    const wer = ((substitutions + deletions + insertions) / m) * 100;
    return {
        wer: Math.min(wer, 100).toFixed(2),
        substitutions,
        deletions,
        insertions,
        total: m
    };
}

function alignTexts(groundTruth, transcription) {
    const m = groundTruth.length;
    const n = transcription.length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    for (let i = 0; i <= m; i++) dp[i][0] = i;
    for (let j = 0; j <= n; j++) dp[0][j] = j;
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (groundTruth[i - 1].toLowerCase() === transcription[j - 1].toLowerCase()) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
            }
        }
    }
    const alignedGroundTruth = [];
    const alignedTranscription = [];
    let i = m, j = n;
    while (i > 0 || j > 0) {
        if (i > 0 && j > 0 && groundTruth[i - 1].toLowerCase() === transcription[j - 1].toLowerCase()) {
            alignedGroundTruth.unshift(groundTruth[i - 1]);
            alignedTranscription.unshift(transcription[j - 1]);
            i--; j--;
        } else if (i > 0 && (j === 0 || dp[i - 1][j] <= dp[i][j - 1])) {
            alignedGroundTruth.unshift(groundTruth[i - 1]);
            alignedTranscription.unshift("");
            i--;
        } else {
            alignedGroundTruth.unshift("");
            alignedTranscription.unshift(transcription[j - 1]);
            j--;
        }
    }
    return { alignedGroundTruth, alignedTranscription };
}

function formatHighlightedText(primaryText, secondaryText) {
    return primaryText.map((word, index) => {
        const isDifferent = word.toLowerCase() !== (secondaryText[index] || "").toLowerCase();
        if (isDifferent) {
            if (word === "") return "";
            if (secondaryText[index] === "") return `<span class="highlight">${word}</span>`;
            return `<span class="highlight">${word}</span>`;
        }
        return word;
    }).join(' ');
}