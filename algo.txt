package vg.rtp;
import java.util.List;

public class RTPPacketAggregator {

    public static byte[] aggregateRTPPackets(List<byte[]> rtpPackets) {
        if (rtpPackets == null || rtpPackets.isEmpty()) {
            throw new IllegalArgumentException("Packet list cannot be null or empty");
        }

        byte[] firstPacket = rtpPackets.get(0);
        int headerLength = 12;
        int totalPayloadLength = 0;

        for (byte[] packet : rtpPackets) {
            totalPayloadLength += (packet.length - headerLength);
        }

        byte[] aggregatedPacket = new byte[headerLength + totalPayloadLength];
        System.arraycopy(firstPacket, 0, aggregatedPacket, 0, headerLength);

        int offset = headerLength;
        for (byte[] packet : rtpPackets) {
            int payloadLength = packet.length - headerLength;
            System.arraycopy(packet, headerLength, aggregatedPacket, offset, payloadLength);
            offset += payloadLength;
        }

        return aggregatedPacket;
    }
}

// ----------------------------

package vg.rtp;

import java.util.Arrays;
import java.util.List;

public class RTPPacketAggregatorTest {

    public static void main(String[] args) {
        // Construct sample RTP packets
        byte[] packet1 = new byte[20];
        byte[] packet2 = new byte[25];
        byte[] packet3 = new byte[30];

        // Set up headers (first 12 bytes) for each packet
        for (int i = 0; i < 12; i++) {
            packet1[i] = (byte) i;
            packet2[i] = (byte) (i + 10);
            packet3[i] = (byte) (i + 20);
        }

        // Set up payloads for each packet
        for (int i = 12; i < packet1.length; i++) {
            packet1[i] = (byte) (i - 12 + 1);
        }
        for (int i = 12; i < packet2.length; i++) {
            packet2[i] = (byte) (i - 12 + 2);
        }
        for (int i = 12; i < packet3.length; i++) {
            packet3[i] = (byte) (i - 12 + 3);
        }

        // Aggregate packets
        List<byte[]> rtpPackets = Arrays.asList(packet1, packet2, packet3);
        byte[] aggregatedPacket = RTPPacketAggregator.aggregateRTPPackets(rtpPackets);

        // Check the structure of the aggregated packet
        int headerLength = 12;
        int expectedPayloadLength = (packet1.length - headerLength) + (packet2.length - headerLength) + (packet3.length - headerLength);
        int expectedTotalLength = headerLength + expectedPayloadLength;

        // Check header (first 12 bytes should be the same as the first packet's header)
        boolean headerMatches = true;
        for (int i = 0; i < headerLength; i++) {
            if (aggregatedPacket[i] != packet1[i]) {
                headerMatches = false;
                break;
            }
        }

        // Check payload
        boolean payloadMatches = true;
        int offset = headerLength;
        for (int i = 12; i < packet1.length; i++) {
            if (aggregatedPacket[offset++] != packet1[i]) {
                payloadMatches = false;
                break;
            }
        }
        for (int i = 12; i < packet2.length; i++) {
            if (aggregatedPacket[offset++] != packet2[i]) {
                payloadMatches = false;
                break;
            }
        }
        for (int i = 12; i < packet3.length; i++) {
            if (aggregatedPacket[offset++] != packet3[i]) {
                payloadMatches = false;
                break;
            }
        }

        // Print results
        System.out.println("Header matches: " + headerMatches + ",  Payload matches: " + payloadMatches);
        System.out.println("Expected total length: " + expectedTotalLength +
                ", Actual total length: " + aggregatedPacket.length);
    }
}

// ----------------------------

package vg.rtp;

import java.util.ArrayList;
import java.util.List;

public class RTPPacketAccumulator {

    public List<byte[]> accumulatePackets(List<byte[]> buffer, int optimalCount, byte[] rtpPacket) {
        long elapsed = System.nanoTime();
        if (buffer == null) {
            buffer = new ArrayList<>();
        }

        buffer.add(rtpPacket);

        if (buffer.size() == optimalCount) {
            return new ArrayList<>(buffer);
        }
        elapsed = System.nanoTime() - elapsed;
        elapsed = elapsed/1000;
        System.out.println("Elapsed time to accumulate: " + elapsed + " microsecs");
        return null;
    }

    public int getOptimalPacketCount(int packetDuration, int optimalDuration) {
        if (packetDuration >= optimalDuration || packetDuration <= 0 || optimalDuration <= 0) {
            return 1;
        }
        return optimalDuration / packetDuration;
    }

    public static void main(String[] args) {
        List<byte[]> buffer = new ArrayList<>();
        int optimalCount = 3;
        RTPPacketAccumulator rpa = new RTPPacketAccumulator();

        byte[] packet1 = new byte[20];
        byte[] packet2 = new byte[25];
        byte[] packet3 = new byte[30];

        // Fill packets with some data (optional)
        for (int i = 0; i < packet1.length; i++) {
            packet1[i] = (byte) i;
        }
        for (int i = 0; i < packet2.length; i++) {
            packet2[i] = (byte) (i + 1);
        }
        for (int i = 0; i < packet3.length; i++) {
            packet3[i] = (byte) (i + 2);
        }

        // Accumulate packets
        List<byte[]> result;

        result = rpa.accumulatePackets(buffer, optimalCount, packet1);
        System.out.println("Buffer size after adding packet1: " + buffer.size() + ", Result: " + result);

        result = rpa.accumulatePackets(buffer, optimalCount, packet2);
        System.out.println("Buffer size after adding packet2: " + buffer.size() + ", Result: " + result);

        result = rpa.accumulatePackets(buffer, optimalCount, packet3);
        System.out.println("Buffer size after adding packet3: " + buffer.size() + ", Result: " + result);

        // If the result is not null, the buffer has reached the optimal count
        if (result != null) {
            System.out.println("Optimal count reached. Buffer contents: ");
            for (byte[] packet : result) {
                System.out.println("Packet length: " + packet.length);
            }
        }
    }
}