import net.sf.fmj.media.rtp.util.RTPPacket;
import org.springframework.integration.aggregator.MessageGroupProcessor;
import org.springframework.integration.store.MessageGroup;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;

import java.util.Collection;

@Component
public class PreVADMessageAggregator implements MessageGroupProcessor {

    @Override
    public Message<?> processMessageGroup(MessageGroup group) {
        Collection<Message<?>> messages = group.getMessages();

        if (messages.isEmpty()) {
            return null;
        }

        RTPPacket firstPacket = (RTPPacket) messages.iterator().next().getPayload();
        byte[] header = extractHeader(firstPacket);
        byte[] aggregatedData = new byte[header.length];

        System.arraycopy(header, 0, aggregatedData, 0, header.length);

        for (Message<?> message : messages) {
            RTPPacket rtpPacket = (RTPPacket) message.getPayload();
            byte[] data = rtpPacket.data;
            aggregatedData = concatenate(aggregatedData, data);
        }

        RTPPacket aggregatedPacket = new RTPPacket();
        aggregatedPacket.payloadType = firstPacket.payloadType;
        aggregatedPacket.seqnum = firstPacket.seqnum;
        aggregatedPacket.timestamp = firstPacket.timestamp;
        aggregatedPacket.ssrc = firstPacket.ssrc;
        aggregatedPacket.data = aggregatedData;
        aggregatedPacket.payloadLength = aggregatedData.length - 12;  // Exclude header length
        aggregatedPacket.payloadoffset = 12;
        aggregatedPacket.length = aggregatedData.length;

        return MessageBuilder.withPayload(aggregatedPacket).build();
    }

    private byte[] extractHeader(RTPPacket packet) {
        byte[] header = new byte[12];
        System.arraycopy(packet.data, 0, header, 0, 12);
        return header;
    }

    private byte[] concatenate(byte[] first, byte[] second) {
        byte[] result = new byte[first.length + second.length];
        System.arraycopy(first, 0, result, 0, first.length);
        System.arraycopy(second, 0, result, first.length, second.length);
        return result;
    }
}

============================================

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.integration.aggregator.AggregatingMessageHandler;
import org.springframework.integration.store.MessageGroupStore;
import org.springframework.integration.store.SimpleMessageStore;
import org.springframework.messaging.MessageHandler;

@Configuration
public class AggregationConfig {

    private int x = 3; //CCHAppResourceBundle.getIntegerProperty(DMLConstants.PRE_VAD_AGGREGATOR_SIZE);
    
    @Bean
    public MessageGroupStore messageStore() {
        return new SimpleMessageStore();
    }

    @Bean
    public MessageHandler aggregatingMessageHandler(PreVADMessageAggregator aggregator) {
        AggregatingMessageHandler handler = new AggregatingMessageHandler(aggregator, messageStore());
        handler.setCorrelationStrategy(message -> ((RTPPacket) message.getPayload()).ssrc);
        handler.setReleaseStrategy(group -> group.size() == x);
        return handler;
    }
}


=============================== SAMPLE ====================

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.integration.dsl.IntegrationFlow;
import org.springframework.integration.dsl.IntegrationFlows;
import org.springframework.integration.dsl.support.Transformers;
import org.springframework.messaging.MessageHandler;
import org.springframework.stereotype.Service;

@Service
public class IntegrationFlowService {

    @Autowired
    private MessageHandler aggregatingMessageHandler;

    @Value("${aggregation.group.size}")
    private int groupSize;

    public IntegrationFlow defineFlow() {
        return IntegrationFlows.from("inputChannel")
                .enrichHeaders(headers -> headers.header("correlationId", "fixedCorrelationId"))
                .transform(new RtpMessageTransformer())  // Assuming RtpMessageTransformer exists
                .filter(m -> m != null)
                .resequence(spec -> spec.correlationStrategy(m -> ((RTPPacket) m.getPayload()).getSsrc())
                                        .releaseStrategy(group -> group.size() == groupSize))
                .filter(m -> true)
                .handle(aggregatingMessageHandler)
                .handle((payload, headers) -> {
                    System.out.println("Aggregated payload: " + payload);
                    return null;
                })
                .get();
    }
}