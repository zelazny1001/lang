package transcriptionviewer;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@RestController
public class CallViewController {
    private String mostRecentCallID = "most recent";
    private List<Boolean> boolData;
    private String viewLocation;
    private List<TranscriptionData> transcriptionDataList;

    @GetMapping("/viewcall")
    public String displayBoolGrid() {
        return generateHtmlContent(boolData, transcriptionDataList);
    }

    public String generateHtmlContent(List<Boolean> boolData, List<TranscriptionData> transcription) {
        double totalDurationSeconds = boolData.size() * CallViewConfig.SECONDS_PER_SAMPLE;
        return new StringBuilder().append(generateHtmlHeader()).append("<body>")
                .append("<h2>Summary for call: ").append(mostRecentCallID).append("</h2>")
                .append(generateSummaryTable(boolData, transcription))
                .append("<br/><br/>").append(generateRulerTable(boolData, totalDurationSeconds))
                .append("<br/><br/>").append("<h2>Detail</h2>")
                .append(generateDetailTable(boolData, transcription))
                .append("<br/><br/>").append("<h2>Transcription</h2>")
                .append(generateTranscriptionTable(transcription))
                .append("</body></html>").toString();
    }

    private String generateTranscriptionTable(List<TranscriptionData> transcriptionDataList) {
        StringBuilder table = new StringBuilder("<table style='font-family: Arial; font-size: 8pt;'>");
        table.append("<tr><th style='width: 50px;'>RowNum</th><th style='width: 60px;'>Start</th><th style='width: 60px;'>Stop</th><th style='width: 60px;'>Duration</th><th>Transcript</th></tr>");

        int rowNum = 1;
        for (TranscriptionData data : transcriptionDataList) {
            double startTime = data.getStartCell() * CallViewConfig.SECONDS_PER_SAMPLE;
            double stopTime = data.getEndCell() * CallViewConfig.SECONDS_PER_SAMPLE;
            double duration = stopTime - startTime;

            table.append("<tr>")
                    .append("<td style='text-align: right;'>").append(rowNum).append("</td>")
                    .append("<td style='text-align: right;'>").append(String.format("%.2f", startTime)).append("</td>")
                    .append("<td style='text-align: right;'>").append(String.format("%.2f", stopTime)).append("</td>")
                    .append("<td style='text-align: right;'>").append(String.format("%.2f", duration)).append("</td>")
                    .append("<td>").append(data.getText()).append("</td>")
                    .append("</tr>");
            rowNum++;
        }

        table.append("</table>");
        return table.toString();
    }

    private String generateHtmlHeader() {
        return new StringBuilder("<html><head>").append("<style>")
                .append("table { border-collapse: collapse; width: 100%; table-layout: fixed;}")
                .append("td { width: ").append(CallViewConfig.CELL_WIDTH).append("px; height: ").append(CallViewConfig.CELL_HEIGHT).append("px; border: 1px solid gray; }")
                .append(".summary-cell { width: ").append(CallViewConfig.SUMMARY_CELL_WIDTH).append("px; height: ").append(CallViewConfig.SUMMARY_CELL_HEIGHT).append("px; border: none; }")
                .append(".green { background-color: green; }").append(".red { background-color: red; }")
                .append(".white { background-color: white; }").append("h2 { font-family: Arial; font-weight: bold; font-size: 14px; }")
                .append(".ruler-cell { font-family: Arial; font-size: 10px; text-align: center; border-top: 1px solid gray; border-bottom: 1px solid gray; border-left: none; border-right: none; }")
                .append(".ruler-transition { border-left: 1px solid black; }").append(".ruler-time { font-family: Arial; font-size: 10px; text-align: center; border-top: 1px solid gray; border-bottom: 1px solid gray; border-left: 1px solid lightgray; border-right: none; }")
                .append("</style></head>").toString();
    }

    private String generateMouseOver(String packetInfo, String timeInfo, String transcription) {
        if (transcription != null) {
            return "title='Pkt " + packetInfo + ", " + timeInfo + " - " + transcription + "'";
        } else {
            return "title='Pkt " + packetInfo + ", " + timeInfo + "'";
        }
    }

    private String generateSummaryTable(List<Boolean> boolData, List<TranscriptionData> transcription) {
        return new StringBuilder("<table><tr>").append(generateSummaryRow(boolData, transcription)).append("</tr></table>").toString();
    }

    private String generateSummaryRow(List<Boolean> boolData, List<TranscriptionData> transcription) {
        StringBuilder summaryRow = new StringBuilder();
        List<Integer> blockSizes = new ArrayList<>();
        List<Boolean> blockTypes = new ArrayList<>();
        boolean currentType = boolData.get(0);
        int currentBlockSize = 0;

        for (Boolean cell : boolData) {
            if (cell == currentType) {
                currentBlockSize++;
            } else {
                blockSizes.add(currentBlockSize);
                blockTypes.add(currentType);
                currentType = cell;
                currentBlockSize = 1;
            }
        }
        blockSizes.add(currentBlockSize);
        blockTypes.add(currentType);

        int totalCells = boolData.size();
        double accumulatedTime = 0.0;
        double timePerColumn = CallViewConfig.SECONDS_PER_SAMPLE * totalCells / CallViewConfig.SUMMARY_COLUMNS;
        int transcriptionIndex = 0;
        TranscriptionData currentTranscription = transcription.isEmpty() ? null : transcription.get(transcriptionIndex);

        for (int i = 0; i < blockSizes.size(); i++) {
            int scaledSize = (int) Math.round((double) blockSizes.get(i) / totalCells * CallViewConfig.SUMMARY_COLUMNS);

            for (int j = 0; j < scaledSize; j++) {
                String timeInfo = String.format("%.2f seconds", accumulatedTime);
                String packetInfo = String.valueOf(i + 1);
                String tooltip;

                if (currentTranscription != null && accumulatedTime >= currentTranscription.getStartCell() * CallViewConfig.SECONDS_PER_SAMPLE &&
                        accumulatedTime <= currentTranscription.getEndCell() * CallViewConfig.SECONDS_PER_SAMPLE) {
                    tooltip = generateMouseOver(packetInfo, timeInfo, currentTranscription.getText());
                } else {
                    tooltip = generateMouseOver(packetInfo, timeInfo, null);
                }

                if (blockTypes.get(i)) {
                    summaryRow.append("<td class='summary-cell green' ").append(tooltip).append("></td>");
                } else {
                    summaryRow.append("<td class='summary-cell red' ").append(tooltip).append("></td>");
                }

                accumulatedTime += timePerColumn;

                if (currentTranscription != null && accumulatedTime > currentTranscription.getEndCell() * CallViewConfig.SECONDS_PER_SAMPLE && transcriptionIndex < transcription.size() - 1) {
                    transcriptionIndex++;
                    currentTranscription = transcription.get(transcriptionIndex);
                }
            }
        }

        return summaryRow.toString();
    }

    private String generateRulerTable(List<Boolean> boolData, double totalDurationSeconds) {
        return new StringBuilder("<table><tr>").append(generateRulerRow(boolData, totalDurationSeconds)).append("</tr></table>").toString();
    }

    private String generateRulerRow(List<Boolean> boolData, double totalDurationSeconds) {
        StringBuilder rulerRow = new StringBuilder();
        List<Integer> blockSizes = new ArrayList<>();
        List<Boolean> blockTypes = new ArrayList<>();
        boolean currentType = boolData.get(0);
        int currentBlockSize = 0;

        for (Boolean cell : boolData) {
            if (cell == currentType) currentBlockSize++;
            else {
                blockSizes.add(currentBlockSize);
                blockTypes.add(currentType);
                currentType = cell;
                currentBlockSize = 1;
            }
        }

        blockSizes.add(currentBlockSize);
        blockTypes.add(currentType);
        double timePerColumn = totalDurationSeconds / CallViewConfig.SUMMARY_COLUMNS;
        double accumulatedTime = 0.0;
        double nextTickMark = CallViewConfig.TICK_INTERVAL_SECONDS;

        for (int i = 0; i < blockSizes.size(); i++) {
            int scaledSize = (int) Math.round((double) blockSizes.get(i) / boolData.size() * CallViewConfig.SUMMARY_COLUMNS);
            for (int j = 0; j < scaledSize; j++) {
                boolean isTransition = (j == 0 && i > 0);
                if (accumulatedTime >= nextTickMark) {
                    rulerRow.append("<td class='ruler-time'>").append((int) nextTickMark).append("</td>");
                    nextTickMark += CallViewConfig.TICK_INTERVAL_SECONDS;
                } else {
                    rulerRow.append("<td class='ruler-cell ").append(isTransition ? "ruler-transition" : "").append("'></td>");
                }
                accumulatedTime += timePerColumn;
            }
        }
        return rulerRow.toString();
    }

    private String generateDetailTable(List<Boolean> boolData, List<TranscriptionData> transcription) {
        StringBuilder detailTable = new StringBuilder("<table>");
        int cellCounter = 0, blockCounter = 0, blocksInCurrentRow = 0;
        int boolDataIndex = 0;
        boolean currentType = boolData.get(0);

        while (boolDataIndex < boolData.size()) {
            while (boolDataIndex < boolData.size() && boolData.get(boolDataIndex) == currentType) {
                if (cellCounter == 0) detailTable.append("<tr>");

                String packetInfo = String.valueOf(boolDataIndex + 1);
                String timeInfo = String.format("%.2f seconds", (boolDataIndex + 1) * CallViewConfig.SECONDS_PER_SAMPLE);
                String tooltip = getTranscriptionForDetailTable(transcription, boolDataIndex, packetInfo, timeInfo);

                detailTable.append("<td class='").append(currentType ? "green" : "red").append("' ")
                        .append(tooltip).append("></td>");

                cellCounter++;
                blockCounter++;
                boolDataIndex++;

                if (blockCounter == CallViewConfig.CELLS_PER_BLOCK) {
                    blocksInCurrentRow++;
                    if (blocksInCurrentRow < CallViewConfig.BLOCKS_PER_ROW) {
                        detailTable.append("<td class='white'></td>");
                        cellCounter++;
                    }
                    blockCounter = 0;
                }

                if (cellCounter == CallViewConfig.CELLS_PER_ROW) {
                    detailTable.append("</tr>");
                    cellCounter = 0;
                    blocksInCurrentRow = 0;
                }
            }

            if (boolDataIndex < boolData.size()) {
                currentType = boolData.get(boolDataIndex);
            }
        }

        if (cellCounter > 0) detailTable.append("</tr>");
        detailTable.append("</table>");
        return detailTable.toString();
    }

    private String getTranscriptionForDetailTable(List<TranscriptionData> transcription, int cellIndex, String packetInfo, String timeInfo) {
        for (TranscriptionData data : transcription) {
            if (cellIndex >= data.getStartCell() && cellIndex <= data.getEndCell()) {
                return generateMouseOver(packetInfo, timeInfo, data.getText());
            }
        }
        return generateMouseOver(packetInfo, timeInfo, null);
    }

    public String getMostRecentCallID() {
        return mostRecentCallID;
    }

    public void setMostRecentCallID(String mostRecentCallID) {
        this.mostRecentCallID = mostRecentCallID;
    }

    public List<Boolean> getBoolData() {
        return boolData;
    }

    public void setBoolData(List<Boolean> boolData) {
        this.boolData = boolData;
    }

    public String getViewLocation() {
        return viewLocation;
    }

    public void setViewLocation(String viewLocation) {
        this.viewLocation = viewLocation;
    }

    public java.util.List<TranscriptionData> getTranscriptionDataList() {
        return transcriptionDataList;
    }

    public void setTranscriptionDataList(java.util.List<TranscriptionData> transcriptionDataList) {
        this.transcriptionDataList = transcriptionDataList;
    }

    public static Path saveToFile(String directory, String fileName, String content) {
        Path filePath = null;
        try {
            Path directoryPath = Paths.get(directory);
            filePath = directoryPath.resolve(fileName);

            Files.createDirectories(directoryPath);
            Files.write(filePath, content.getBytes());
        } catch (Exception e) {
            System.out.println("Exception: " + e.getMessage());
        }
        return filePath;
    }

    public static List<TranscriptionData> getTranscriptionDataFromFile(String filename) {
        try {
            return Files.lines(Paths.get(filename))
                    .map(line -> {
                        String[] parts = line.split("\\|");
                        return new TranscriptionData(parts[0], Integer.parseInt(parts[1]), Integer.parseInt(parts[2]), parts[3]);
                    })
                    .collect(Collectors.toList());
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}