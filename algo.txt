package analyzer;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.List;

public class RulesEngineAnalysisFormatter {
    public static void main(String[] args) throws IOException {
        String inputFilename = "/tmp/rules-engine-analysis.txt";
        Path inputPath = Paths.get(inputFilename);
        String outputFilename = createOutputFilename(inputPath);

        List<String> inputLines = Files.readAllLines(inputPath);
        List<String> outputLines = formatAnalysis(inputLines);

        Files.write(Paths.get(outputFilename), outputLines, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
    }

    private static String createOutputFilename(Path inputPath) {
        String directory = inputPath.getParent().toString();
        return directory + File.separator + "formatted-analysis.txt";
    }

    private static List<String> formatAnalysis(List<String> inputLines) throws IOException {
        List<String> outputLines = new ArrayList<>();
        outputLines.add("filename | enforced | seqNum | start | end | transcript | preZeros | postZeros | length | hallucination");

        String currentFilename = null;
        Boolean currentEnforced = null;
        List<String> batchLines = new ArrayList<>();

        for (String line : inputLines) {
            if (line.trim().isEmpty()) {
                continue;
            } else if (line.startsWith("=")) {
                if (!batchLines.isEmpty()) {
                    processBatch(batchLines, Paths.get(currentFilename), currentEnforced, outputLines);
                    batchLines.clear();
                }
                currentFilename = null;
                currentEnforced = null;
            } else if (line.startsWith("/")) {
                currentFilename = line;
            } else if (line.equals("with rules / no enforcement")) {
                if (!batchLines.isEmpty()) {
                    processBatch(batchLines, Paths.get(currentFilename), currentEnforced, outputLines);
                    batchLines.clear();
                }
                currentEnforced = false;
            } else if (line.equals("with rules / with enforcement")) {
                if (!batchLines.isEmpty()) {
                    processBatch(batchLines, Paths.get(currentFilename), currentEnforced, outputLines);
                    batchLines.clear();
                }
                currentEnforced = true;
            } else if (line.startsWith("-")) {
                continue;
            } else if (line.contains("Sequence Number Range:")) {
                batchLines.add(line);
            }
        }

        if (!batchLines.isEmpty()) {
            processBatch(batchLines, Paths.get(currentFilename), currentEnforced, outputLines);
        }

        return outputLines;
    }

    private static void processBatch(List<String> batchLines, Path filePath, Boolean currentEnforced, List<String> outputLines) throws IOException {
        if (currentEnforced == null || filePath == null) {
            throw new IllegalArgumentException("Filename and enforcement value must be set before processing a batch");
        }

        byte[] fileBytes = G711Codec.readAllBytes(new FileInputStream(filePath.toFile()));

        for (String batchLine : batchLines) {
            int startIndex = batchLine.indexOf("Sequence Number Range: ") + "Sequence Number Range: ".length();
            int endIndex = batchLine.indexOf("-", startIndex);
            int seqNumIndex = batchLine.indexOf("New Sequence Number: ");
            int transcriptIndex = batchLine.indexOf("Transcription: ");

            if (startIndex < 0 || endIndex < 0 || seqNumIndex < 0 || transcriptIndex < 0) {
                throw new IllegalArgumentException("Batch line is not formatted correctly: " + batchLine);
            }

            String rangePart = batchLine.substring(startIndex, endIndex).trim();
            String[] rangeSplit = rangePart.split("-");
            if (rangeSplit.length != 2) {
                throw new IllegalArgumentException("Sequence number range is not formatted correctly: " + rangePart);
            }

            int start = Integer.parseInt(rangeSplit[0].trim()) - 1;
            int end = Integer.parseInt(rangeSplit[1].trim()) - 1;
            int seqNum = Integer.parseInt(batchLine.substring(seqNumIndex + "New Sequence Number: ".length(), batchLine.indexOf(",", seqNumIndex)).trim());
            String transcript = batchLine.substring(transcriptIndex + "Transcription: ".length()).trim();

            int preZeros = countContiguousBytesBefore(fileBytes, start);
            int postZeros = countContiguousBytesAfter(fileBytes, end);
            int length = countSignificantBytes(fileBytes, start, end);
            boolean hallucination = (preZeros <= 2 && postZeros <= 2);

            String outputLine = String.join(" | ",
                    filePath.getFileName().toString().replaceFirst("\\.raw", ""),
                    currentEnforced ? "true" : "false",
                    String.valueOf(seqNum),
                    String.valueOf(start + 1),
                    String.valueOf(end + 1),
                    transcript,
                    String.valueOf(preZeros),
                    String.valueOf(postZeros),
                    String.valueOf(length),
                    String.valueOf(hallucination)
            );
            outputLines.add(outputLine);
        }
    }

    private static int extractInteger(String text, String startDelimiter, String endDelimiter) {
        int startIndex = text.indexOf(startDelimiter) + startDelimiter.length();
        int endIndex = (endDelimiter != null) ? text.indexOf(endDelimiter, startIndex) : text.length();
        return Integer.parseInt(text.substring(startIndex, endIndex).trim());
    }

    private static String extractText(String text, String delimiter) {
        return text.substring(text.indexOf(delimiter) + delimiter.length()).trim();
    }

    private static int countContiguousBytesBefore(byte[] bytes, int position) {
        int count = 0;
        for (int i = position - 1; i >= 0; i--) {
            if (bytes[i] == -1 || bytes[i] == 127) {
                count++;
            } else {
                break;
            }
        }
        return count;
    }

    private static int countContiguousBytesAfter(byte[] bytes, int position) {
        int count = 0;
        for (int i = position + 1; i < bytes.length; i++) {
            if (bytes[i] == -1 || bytes[i] == 127) {
                count++;
            } else {
                break;
            }
        }
        return count;
    }

    private static int countSignificantBytes(byte[] bytes, int start, int end) {
        int count = 0;
        for (int i = start; i <= end; i++) {
            if (bytes[i] != -1 && bytes[i] != 127) {
                count++;
            }
        }
        return count;
    }
}