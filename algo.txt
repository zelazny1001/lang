package analyzer;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.List;

public class RulesEngineAnalysisFormatter {
    private static String createOutputFilename(Path inputPath) {
        String directory = inputPath.getParent().toString();
        return directory + File.separator + "formatted-analysis.txt";
    }

    private static List<String> formatAnalysis(List<String> inputLines) throws IOException {
        List<String> outputLines = new ArrayList<>();
        outputLines.add("filename | enforced | seqNum | start | end | transcript | tokens | samples | samples.per.token");

        String currentFilename = null;
        Boolean currentEnforced = null;
        List<String> batchLines = new ArrayList<>();

        for (String line : inputLines) {
            if (line.trim().isEmpty()) {
                continue;
            } else if (line.startsWith("=")) {
                if (!batchLines.isEmpty()) {
                    processBatch(batchLines, Paths.get(currentFilename), currentEnforced, outputLines);
                    batchLines.clear();
                }
                currentFilename = null;
                currentEnforced = null;
            } else if (line.startsWith("/")) {
                currentFilename = line;
            } else if (line.equals("with rules / no enforcement")) {
                if (!batchLines.isEmpty()) {
                    processBatch(batchLines, Paths.get(currentFilename), currentEnforced, outputLines);
                    batchLines.clear();
                }
                currentEnforced = false;
            } else if (line.equals("with rules / with enforcement")) {
                if (!batchLines.isEmpty()) {
                    processBatch(batchLines, Paths.get(currentFilename), currentEnforced, outputLines);
                    batchLines.clear();
                }
                currentEnforced = true;
            } else if (line.startsWith("-")) {
                continue;
            } else if (line.contains("Sequence Number Range:")) {
                batchLines.add(line);
            }
        }

        if (!batchLines.isEmpty()) {
            processBatch(batchLines, Paths.get(currentFilename), currentEnforced, outputLines);
        }

        return outputLines;
    }

    private static void processBatch(List<String> batchLines, Path filePath, Boolean currentEnforced, List<String> outputLines) throws IOException {
        if (currentEnforced == null || filePath == null) {
            throw new IllegalArgumentException("Filename and enforcement value must be set before processing a batch");
        }

        for (String batchLine : batchLines) {
            int startIndex = batchLine.indexOf("Sequence Number Range: ") + "Sequence Number Range: ".length();
            int endIndex = batchLine.indexOf(",", startIndex);
            int seqNumIndex = batchLine.indexOf("New Sequence Number: ");
            int transcriptIndex = batchLine.indexOf("Transcription: ");

            if (startIndex < 0 || endIndex < 0 || seqNumIndex < 0 || transcriptIndex < 0) {
                throw new IllegalArgumentException("Batch line is not formatted correctly: " + batchLine);
            }

            String rangePart = batchLine.substring(startIndex, endIndex).trim();
            String[] rangeSplit = rangePart.split("-");
            if (rangeSplit.length != 2) {
                throw new IllegalArgumentException("Sequence number range is not formatted correctly: " + rangePart);
            }

            int start = Integer.parseInt(rangeSplit[0].trim()) - 1;
            int end = Integer.parseInt(rangeSplit[1].trim()) - 1;
            int seqNum = Integer.parseInt(batchLine.substring(seqNumIndex + "New Sequence Number: ".length(), batchLine.indexOf(",", seqNumIndex)).trim());
            String transcript = batchLine.substring(transcriptIndex + "Transcription: ".length()).trim();

            int tokens = countTokens(transcript);
            int samples = end - start;
            double samplesPerToken = tokens > 0 ? (double) samples / tokens : 0;

            String outputLine = String.join(" | ",
                    filePath.getFileName().toString().replaceFirst("\\.raw", ""),
                    currentEnforced ? "true" : "false",
                    String.valueOf(seqNum),
                    String.valueOf(start + 1),
                    String.valueOf(end + 1),
                    transcript,
                    String.valueOf(tokens),
                    String.valueOf(samples),
                    String.format("%.2f", samplesPerToken)
            );
            outputLines.add(outputLine);
        }
    }

    private static int countTokens(String transcript) {
        String[] tokens = transcript.split("[\\s-]+");
        int tokenCount = 0;

        for (String token : tokens) {
            if (token.isEmpty()) {
                continue; // Skip empty tokens resulting from multiple spaces or dashes
            }
            if (!token.matches("[a-zA-Z0-9!@#$%&,.;?\\- ]+")) {
                return 0; // Invalid character found, set token count to zero
            }
            if (token.matches("\\$\\d+\\.?")) {
                tokenCount += token.replaceAll("[^\\d]", "").length() + 1;
            } else if (token.matches("\\d{3,}\\.?")) {
                tokenCount += token.replaceAll("[^\\d]", "").length();
            } else if (token.matches("\\d+\\.\\d+")) {
                tokenCount += token.replaceAll("[^\\d]", "").length();
            } else {
                tokenCount += 1;
            }
        }

        return tokenCount;
    }

    public static void main2(String[] args) throws IOException {
        String inputFilename = "/tmp/rules-engine-analysis.txt";
        Path inputPath = Paths.get(inputFilename);
        String outputFilename = createOutputFilename(inputPath);

        List<String> inputLines = Files.readAllLines(inputPath);
        List<String> outputLines = formatAnalysis(inputLines);

        Files.write(Paths.get(outputFilename), outputLines, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
    }

    public static void main(String[] args) {
        String t = " Let me check this, ? -";
        int count = countTokens(t);
        System.out.println("count: " + count);
    }
}