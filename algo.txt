package analyzer;

import java.util.Map;
import java.util.HashMap;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioFormat;

public class G711Codec {
    private static final int BIAS = 132;
    public static final Map<Byte, Integer> muLawDecodeMap = new HashMap<>();

    static {
        for (int i=0; i<=255; i++) {
            byte b = (byte) i;
            muLawDecodeMap.put(b, decodeAlgorithm(b));
        }
    }

    public static int decodeByte(byte b) {
        return muLawDecodeMap.get(b);
    }

    public static float toNormalizedPCM(byte b) {
        return muLawDecodeMap.get(b) / 32768.0f;
    }

    public static float[] g711ByteArrayToNormalizedPCM(byte[] g711Data) {
        float[] pcmData = new float[g711Data.length];
        for (int i = 0; i < g711Data.length; i ++) {
            pcmData[i] = toNormalizedPCM(g711Data[i]);
        }
        return pcmData;
    }

    public static float[] muLawToFloat(byte[] muLawData) {
        float[] pcmData = new float[muLawData.length];
        for (int i = 0; i < muLawData.length; i++) {
            pcmData[i] = decodeAlgorithm(muLawData[i]) / 32768.0f;
        }
        return pcmData;
    }

    private static int decodeAlgorithm(byte g711Byte) { // decode 8-bit G711 mulaw byte into a 16-bit signed PCM value

        // 16-bit signed value
        g711Byte = (byte) ~g711Byte;

        int sign = g711Byte & 0x80;
        int exponent = (g711Byte & 0x70) >> 4;
        int mantissa = g711Byte & 0x0F;
        int sample = (mantissa << (exponent + 3)) + (BIAS << exponent) - BIAS;
        if (sign != 0) {
            sample = -sample;
        }
        return sample;
    }

    public static AudioInputStream convertG711ToAudioStream(byte[] g711) {
        AudioInputStream result = null;
        float sampleRate = 8000.0f;
        int sampleSizeInBits = 16;
        int channels = 1;
        boolean signed = true;
        boolean bigEndian = false;
        byte[] pcmData = g711ByteArrayToPCMByteArray(g711);
        AudioFormat format = new AudioFormat(sampleRate, sampleSizeInBits, channels, signed, bigEndian);
        result = new AudioInputStream(new ByteArrayInputStream(pcmData),
                format, pcmData.length / format.getFrameSize());
        return result;
    }

    public static byte[] g711ByteArrayToPCMByteArray(byte[] g711Data) {
        byte[] pcmData = new byte[g711Data.length * 2];
        for (int i = 0; i < g711Data.length; i ++) {
            int pcmSample = decodeAlgorithm(g711Data[i]);
            pcmData[2 * i] = (byte) (pcmSample & 0xFF);
            pcmData[2 * i + 1] = (byte) ((pcmSample >> 8) & 0xFF);
        }
        return pcmData;
    }

    public static byte[] readAllBytes(InputStream inputStream) {
        try {
            byte[] buffer = new byte[8192];
            int bytesRead;
            ByteArrayOutputStream output = new ByteArrayOutputStream();
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                output.write(buffer, 0, bytesRead);
            }
            return output.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
            return new byte[0];
        }
    }

    public static void main(String[] args) {
        for (int i=0; i<=255; i++) {
            byte b = (byte) i;
            System.out.println(String.format("byte: %d, pcm: %d, normalized: %f", b, muLawDecodeMap.get(b), toNormalizedPCM(b)));
        }
    }
}