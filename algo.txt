package analyzer;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.List;

public class RulesEngineAnalysisFormatter {
    public static void main(String[] args) throws IOException {
        String inputFilename = "/tmp/rules-engine-analysis.txt";
        Path inputPath = Paths.get(inputFilename);
        String outputFilename = createOutputFilename(inputPath);

        List<String> inputLines = Files.readAllLines(inputPath);
        List<String> outputLines = formatAnalysis(inputLines);

        Files.write(Paths.get(outputFilename), outputLines, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
    }

    private static String createOutputFilename(Path inputPath) {
        String directory = inputPath.getParent().toString();
        return directory + File.separator + "formatted-analysis.txt";
    }

    private static List<String> formatAnalysis(List<String> inputLines) throws IOException {
        List<String> outputLines = new ArrayList<>();
        outputLines.add("filename | enforced | seqNum | start | end | transcript | preZeros | postZeros | length | hallucination");

        String currentFilename = null;
        Boolean currentEnforced = null;
        List<String> batchLines = new ArrayList<>();

        for (String line : inputLines) {
            if (line.trim().isEmpty()) {
                // Skip blank lines
                continue;
            } else if (line.startsWith("=")) {
                // New section marker
                System.out.println("New section marker detected.");
                if (!batchLines.isEmpty()) {
                    System.out.println("Processing batch before moving to new section. Enforced: " + currentEnforced);
                    processBatch(batchLines, Paths.get(currentFilename), currentEnforced, outputLines);
                    batchLines.clear();
                }
                currentFilename = null;
                currentEnforced = null;
            } else if (line.startsWith("/")) {
                // Set the filename for the current section
                currentFilename = line;
                System.out.println("Filename set for current section: " + currentFilename);
            } else if (line.equals("with rules / no enforcement")) {
                // Set enforcement to false, and prepare to collect data for this batch
                if (!batchLines.isEmpty()) {
                    processBatch(batchLines, Paths.get(currentFilename), currentEnforced, outputLines);
                    batchLines.clear();
                }
                currentEnforced = false;
                System.out.println("Enforcement set to FALSE for the upcoming batch.");
            } else if (line.equals("with rules / with enforcement")) {
                // Set enforcement to true, and prepare to collect data for this batch
                if (!batchLines.isEmpty()) {
                    processBatch(batchLines, Paths.get(currentFilename), currentEnforced, outputLines);
                    batchLines.clear();
                }
                currentEnforced = true;
                System.out.println("Enforcement set to TRUE for the upcoming batch.");
            } else if (line.startsWith("-")) {
                // Batch separator: Begin collecting sequence data for the batch
                // No need to process anything yet, as the "-" marks start of data for current enforcement
                System.out.println("Batch marker '-' detected. Preparing to collect sequence data for enforcement: " + currentEnforced);
            } else if (line.contains("Sequence Number Range:")) {
                // Add lines containing sequence information to the current batch
                batchLines.add(line);
                System.out.println("Adding line to batch: " + line);
            }
        }

        // Process any remaining batch at the end of the file
        if (!batchLines.isEmpty()) {
            System.out.println("Processing final batch. Current enforcement: " + currentEnforced);
            processBatch(batchLines, Paths.get(currentFilename), currentEnforced, outputLines);
        }

        return outputLines;
    }

    private static void processBatch(List<String> batchLines, Path filePath, Boolean currentEnforced, List<String> outputLines) throws IOException {
        if (currentEnforced == null || filePath == null) {
            throw new IllegalArgumentException("Filename and enforcement value must be set before processing a batch");
        }

        System.out.println("Processing batch with filename: " + filePath + " and enforcement: " + currentEnforced);

        for (String batchLine : batchLines) {
            String[] parts = batchLine.split(",");
            int start = extractInteger(parts[0], "Sequence Number Range: ", "-");
            int end = extractInteger(parts[0], "-", null);
            int seqNum = extractInteger(parts[1], "New Sequence Number: ", null);
            String transcript = extractText(parts[2], "Transcription: ");

            byte[] fileBytes = G711Codec.readAllBytes(new FileInputStream(filePath.toFile()));
            int preZeros = countContiguousBytesBefore(fileBytes, start);
            int postZeros = countContiguousBytesAfter(fileBytes, end);
            int length = countSignificantBytes(fileBytes, start, end);
            boolean hallucination = (preZeros <= 2 && postZeros <= 2);

            String outputLine = String.join(" | ",
                    filePath.getFileName().toString().replaceFirst("\\.raw", ""),
                    currentEnforced ? "true" : "false",
                    String.valueOf(seqNum),
                    String.valueOf(start),
                    String.valueOf(end),
                    transcript,
                    String.valueOf(preZeros),
                    String.valueOf(postZeros),
                    String.valueOf(length),
                    String.valueOf(hallucination)
            );
            outputLines.add(outputLine);
        }
    }

    private static int extractInteger(String text, String startDelimiter, String endDelimiter) {
        int startIndex = text.indexOf(startDelimiter) + startDelimiter.length();
        int endIndex = (endDelimiter != null) ? text.indexOf(endDelimiter, startIndex) : text.length();
        return Integer.parseInt(text.substring(startIndex, endIndex).trim());
    }

    private static String extractText(String text, String delimiter) {
        return text.substring(text.indexOf(delimiter) + delimiter.length()).trim();
    }

    private static int countContiguousBytesBefore(byte[] bytes, int position) {
        int count = 0;
        for (int i = position - 1; i >= 0; i--) {
            if (bytes[i] == -1 || bytes[i] == 127) {
                count++;
            } else {
                break;
            }
        }
        return count;
    }

    private static int countContiguousBytesAfter(byte[] bytes, int position) {
        int count = 0;
        for (int i = position + 1; i < bytes.length; i++) {
            if (bytes[i] == -1 || bytes[i] == 127) {
                count++;
            } else {
                break;
            }
        }
        return count;
    }

    private static int countSignificantBytes(byte[] bytes, int start, int end) {
        int count = 0;
        for (int i = start; i <= end; i++) {
            if (bytes[i] != -1 && bytes[i] != 127) {
                count++;
            }
        }
        return count;
    }
}