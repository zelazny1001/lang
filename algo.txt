package analyzer;

import java.util.Map;
import java.util.HashMap;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioFormat;

public class G711Codec {
    private static final int BIAS = 132;
    public static final Map<Byte, Integer> muLawDecodeMap = new HashMap<>();

    static {
        for (int i=0; i<=255; i++) {
            byte b = (byte) i;
            muLawDecodeMap.put(b, decodeAlgorithm(b));
        }
    }

    public static int decodeByte(byte b) {
        return muLawDecodeMap.get(b);
    }

    public static float toNormalizedPCM(byte b) {
        return muLawDecodeMap.get(b) / 32768.0f;
    }

    public static float[] g711ByteArrayToNormalizedPCM(byte[] g711Data) {
        float[] pcmData = new float[g711Data.length];
        for (int i = 0; i < g711Data.length; i ++) {
            pcmData[i] = toNormalizedPCM(g711Data[i]);
        }
        return pcmData;
    }

    public static float[] g711ByteArrayToNormalizedLinearPCM(byte[] g711Data) {
        float[] pcmData = new float[g711Data.length];
        for (int i = 0; i < g711Data.length; i ++) {
            byte linearByte = toLinearByte(g711Data[i]);
            pcmData[i] = toNormalizedPCM(linearByte);
        }
        return pcmData;
    }

    public static float[] muLawToFloat(byte[] muLawData) {
        float[] pcmData = new float[muLawData.length];
        for (int i = 0; i < muLawData.length; i++) {
            pcmData[i] = decodeAlgorithm(muLawData[i]) / 32768.0f;
        }
        return pcmData;
    }

    private static int decodeAlgorithm(byte g711Byte) { // decode 8-bit G711 mulaw byte into a 16-bit signed PCM value
        // 16-bit signed value
        g711Byte = (byte) ~g711Byte;

        int sign = g711Byte & 0x80;
        int exponent = (g711Byte & 0x70) >> 4;
        int mantissa = g711Byte & 0x0F;
        int sample = (mantissa << (exponent + 3)) + (BIAS << exponent) - BIAS;
        if (sign != 0) {
            sample = -sample;
        }
        return sample;
    }

    public static AudioInputStream convertG711ToAudioStream(byte[] g711) {
        AudioInputStream result = null;
        float sampleRate = 8000.0f;
        int sampleSizeInBits = 16;
        int channels = 1;
        boolean signed = true;
        boolean bigEndian = false;
        byte[] pcmData = g711ByteArrayToPCMByteArray(g711);
        AudioFormat format = new AudioFormat(sampleRate, sampleSizeInBits, channels, signed, bigEndian);
        result = new AudioInputStream(new ByteArrayInputStream(pcmData),
                format, pcmData.length / format.getFrameSize());
        return result;
    }

    public static byte[] g711ByteArrayToPCMByteArray(byte[] g711Data) {
        byte[] pcmData = new byte[g711Data.length * 2];
        for (int i = 0; i < g711Data.length; i ++) {
            int pcmSample = decodeAlgorithm(g711Data[i]);
            pcmData[2 * i] = (byte) (pcmSample & 0xFF);
            pcmData[2 * i + 1] = (byte) ((pcmSample >> 8) & 0xFF);
        }
        return pcmData;
    }

    public static byte[] readAllBytes(InputStream inputStream) {
        try {
            byte[] buffer = new byte[8192];
            int bytesRead;
            ByteArrayOutputStream output = new ByteArrayOutputStream();
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                output.write(buffer, 0, bytesRead);
            }
            return output.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
            return new byte[0];
        }
    }

    private static int decodeAlgorithm_original(byte g711Byte) {
        System.out.println("Original byte (signed): " + g711Byte);
        int unsignedByte = g711Byte & 0xFF; // Convert signed byte to unsigned
        System.out.println("Converted to unsigned byte: " + unsignedByte);

        unsignedByte = ~unsignedByte & 0xFF; // Bit-flip the unsigned byte
        System.out.println("Bit-flipped byte: " + unsignedByte);

        int sign = unsignedByte & 0x80;
        int exponent = (unsignedByte & 0x70) >> 4;
        int mantissa = unsignedByte & 0x0F;
        System.out.println("Sign: " + (sign == 0x80 ? "Negative" : "Positive"));
        System.out.println("Exponent: " + exponent);
        System.out.println("Mantissa: " + mantissa);

        int sample = (mantissa << (exponent + 3)) + (BIAS << exponent) - BIAS;
        if (sign != 0) {
            sample = -sample;
        }
        System.out.println("Decoded PCM: " + sample);
        return sample;
    }

    private static float normalizePCM(int pcmValue) {
        return pcmValue / 32768.0f;
    }

    public static byte toLinearByte(byte b) {
        if (b == 127) return 0;
        if (b == -1) return 0;
        if (b > 0) return (byte) (128 - 0);
        return b;
    }

    public static void main(String[] args) {
        for (int i=-128; i<=127; i++) {
            byte b = (byte) i;
            //System.out.println(String.format("byte: %d, pcm: %d, normalized: %f", b, muLawDecodeMap.get(b), toNormalizedPCM(b)));
            System.out.println(String.format("byte: %d, conv: %d", b, muLawDecodeMap.get(b)));
        }
    }

    public static void main3(String[] args) {
        // Test byte values around the critical transition point
        for (int i = -10; i <= 10; i++) {
            byte testByte = (byte) i;
            //int prior_decoded = decodeAlgorithm(testByte);
            int decodedValue = decodeAlgorithm_original(testByte);
            float normalizedValue = normalizePCM(decodedValue);
            //float prior_normalized = normalizePCM(prior_decoded);
            System.out.println("byte: " + i + ", pcm: " + decodedValue + ", normalized: " + normalizedValue);
            //System.out.println("byte: " + i + ", prior_pcm: " + prior_decoded + ", prior_normalized: " + prior_normalized);
        }
    }
}