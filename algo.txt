package analyzer;

import java.util.Map;
import java.util.HashMap;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioFormat;

public class G711Codec {
    private static final int BIAS = 132;
    public static final Map<Byte, Integer> muLawDecodeMap = new HashMap<>();

    static {
        for (int i=0; i<=255; i++) {
            byte b = (byte) i;
            muLawDecodeMap.put(b, decodeAlgorithm(b));
        }
    }

    public static int decodeByte(byte b) {
        return muLawDecodeMap.get(b);
    }

    public static float toNormalizedPCM(byte b) {
        return muLawDecodeMap.get(b) / 32768.0f;
    }

    public static float[] g711ByteArrayToNormalizedPCM(byte[] g711Data) {
        float[] pcmData = new float[g711Data.length];
        for (int i = 0; i < g711Data.length; i ++) {
            pcmData[i] = toNormalizedPCM(g711Data[i]);
        }
        return pcmData;
    }

    public static float[] g711ByteArrayToNormalizedLinearPCM(byte[] g711Data) {
        float[] pcmData = new float[g711Data.length];
        for (int i = 0; i < g711Data.length; i ++) {
            byte linearByte = toLinearByte(g711Data[i]);
            pcmData[i] = toNormalizedPCM(linearByte);
        }
        return pcmData;
    }

    public static float[] muLawToFloat(byte[] muLawData) {
        float[] pcmData = new float[muLawData.length];
        for (int i = 0; i < muLawData.length; i++) {
            pcmData[i] = decodeAlgorithm(muLawData[i]) / 32768.0f;
        }
        return pcmData;
    }

    private static int decodeAlgorithm(byte g711Byte) { // decode 8-bit G711 mulaw byte into a 16-bit signed PCM value
        // 16-bit signed value
        g711Byte = (byte) ~g711Byte;

        int sign = g711Byte & 0x80;
        int exponent = (g711Byte & 0x70) >> 4;
        int mantissa = g711Byte & 0x0F;
        int sample = (mantissa << (exponent + 3)) + (BIAS << exponent) - BIAS;
        if (sign != 0) {
            sample = -sample;
        }
        return sample;
    }

    public static AudioInputStream convertG711ToAudioStream(byte[] g711) {
        AudioInputStream result = null;
        float sampleRate = 8000.0f;
        int sampleSizeInBits = 16;
        int channels = 1;
        boolean signed = true;
        boolean bigEndian = false;
        byte[] pcmData = g711ByteArrayToPCMByteArray(g711);
        AudioFormat format = new AudioFormat(sampleRate, sampleSizeInBits, channels, signed, bigEndian);
        result = new AudioInputStream(new ByteArrayInputStream(pcmData),
                format, pcmData.length / format.getFrameSize());
        return result;
    }

    public static byte[] g711ByteArrayToPCMByteArray(byte[] g711Data) {
        byte[] pcmData = new byte[g711Data.length * 2];
        for (int i = 0; i < g711Data.length; i ++) {
            int pcmSample = decodeAlgorithm(g711Data[i]);
            pcmData[2 * i] = (byte) (pcmSample & 0xFF);
            pcmData[2 * i + 1] = (byte) ((pcmSample >> 8) & 0xFF);
        }
        return pcmData;
    }

    public static byte[] readAllBytes(InputStream inputStream) {
        try {
            byte[] buffer = new byte[8192];
            int bytesRead;
            ByteArrayOutputStream output = new ByteArrayOutputStream();
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                output.write(buffer, 0, bytesRead);
            }
            return output.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
            return new byte[0];
        }
    }

    private static int decodeAlgorithm_original(byte g711Byte) {
        System.out.println("Original byte (signed): " + g711Byte);
        int unsignedByte = g711Byte & 0xFF; // Convert signed byte to unsigned
        System.out.println("Converted to unsigned byte: " + unsignedByte);

        unsignedByte = ~unsignedByte & 0xFF; // Bit-flip the unsigned byte
        System.out.println("Bit-flipped byte: " + unsignedByte);

        int sign = unsignedByte & 0x80;
        int exponent = (unsignedByte & 0x70) >> 4;
        int mantissa = unsignedByte & 0x0F;
        System.out.println("Sign: " + (sign == 0x80 ? "Negative" : "Positive"));
        System.out.println("Exponent: " + exponent);
        System.out.println("Mantissa: " + mantissa);

        int sample = (mantissa << (exponent + 3)) + (BIAS << exponent) - BIAS;
        if (sign != 0) {
            sample = -sample;
        }
        System.out.println("Decoded PCM: " + sample);
        return sample;
    }

    private static float normalizePCM(int pcmValue) {
        return pcmValue / 32768.0f;
    }

    public static byte toLinearByte(byte b) {
        if (b == 127) return 0;
        if (b == -1) return 0;
        if (b > 0) return (byte) (128 - 0);
        return b;
    }

    public static void main(String[] args) {
        for (int i=-128; i<=127; i++) {
            byte b = (byte) i;
            //System.out.println(String.format("byte: %d, pcm: %d, normalized: %f", b, muLawDecodeMap.get(b), toNormalizedPCM(b)));
            System.out.println(String.format("byte: %d, conv: %d", b, muLawDecodeMap.get(b)));
        }
    }

    public static void main3(String[] args) {
        // Test byte values around the critical transition point
        for (int i = -10; i <= 10; i++) {
            byte testByte = (byte) i;
            //int prior_decoded = decodeAlgorithm(testByte);
            int decodedValue = decodeAlgorithm_original(testByte);
            float normalizedValue = normalizePCM(decodedValue);
            //float prior_normalized = normalizePCM(prior_decoded);
            System.out.println("byte: " + i + ", pcm: " + decodedValue + ", normalized: " + normalizedValue);
            //System.out.println("byte: " + i + ", prior_pcm: " + prior_decoded + ", prior_normalized: " + prior_normalized);
        }
    }

}

===========

package analyzer;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;

public class VADAnalyzer {
    private static final Map<String, byte[]> fileDataMap = new HashMap<>();
    private static byte[] activeFileData;
    private static String activeFileName;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("VADAnalyzer started. Enter commands:");
        String input;
        while (true) {
            input = scanner.nextLine();
            if (input.trim().isEmpty()) continue;
            String[] commands = input.split("\\s+");
            String command = commands[0].toLowerCase();
            switch (command) {
                case "quit":
                case "exit":
                case "q":
                    System.out.println("Exiting VADAnalyzer.");
                    scanner.close();
                    return;
                case "header":
                    header();
                    break;
                case "load":
                    if (commands.length > 1) {
                        load(commands[1]);
                    } else {
                        System.out.println("Error: 'load' command requires the name of the G711 raw file to be loaded.");
                    }
                    break;
                case "play":
                    if (commands.length > 2) {
                        play(Integer.parseInt(commands[1]), Integer.parseInt(commands[2]));
                    } else {
                        System.out.println("Error: 'play' command requires the start and end integer indices.");
                    }
                    break;
                case "append":
                    if (commands.length > 2) {
                        append(Integer.parseInt(commands[1]), Integer.parseInt(commands[2]));
                    } else {
                        System.out.println("Error: 'append' command requires the start and end integer indices.");
                    }
                    break;
                default:
                    System.out.println("Invalid command. Try again.");
            }
        }
    }

    private static void load(String fileName) {
        File directory = new File("/path/to/search/directory");
        File[] files = directory.listFiles();
        List<File> matchedFiles = new ArrayList<>();
        if (files != null) {
            for (File file : files) {
                if (file.getName().contains(fileName)) {
                    matchedFiles.add(file);
                }
            }
        }
        if (matchedFiles.isEmpty()) {
            System.out.println("No file matches found. Please enter the full path to the file.");
        } else if (matchedFiles.size() == 1) {
            loadFileIntoMemory(matchedFiles.get(0));
        } else {
            System.out.println("Multiple files match the description:");
            for (int i = 0; i < matchedFiles.size(); i++) {
                System.out.println((i + 1) + ": " + matchedFiles.get(i).getName());
            }
            System.out.println("Enter the number of the file you want to load:");
            Scanner scanner = new Scanner(System.in);
            int choice = scanner.nextInt();
            loadFileIntoMemory(matchedFiles.get(choice - 1));
        }
    }

    private static void loadFileIntoMemory(File file) {
        try {
            InputStream inputStream = new FileInputStream(file);
            byte[] data = G711Codec.readAllBytes(inputStream);
            String fileName = file.getName();
            fileDataMap.put(fileName, data);
            activeFileData = data;
            activeFileName = fileName;
            System.out.println("Loaded file: " + fileName);
        } catch (FileNotFoundException e) {
            System.out.println("File not found: " + file.getPath());
        } catch (IOException e) {
            System.out.println("Error reading file: " + file.getPath());
        }
    }

    private static void play(int start, int end) {
        if (activeFileData == null) {
            System.out.println("No file loaded.");
            return;
        }
        try {
            byte[] slice = Arrays.copyOfRange(activeFileData, start, end + 1);
            AudioInputStream audioStream = G711Codec.convertG711ToAudioStream(slice);
            Clip clip = AudioSystem.getClip();
            clip.open(audioStream);
            clip.start();
            while (!clip.isRunning())
                Thread.sleep(10);
            while (clip.isRunning())
                Thread.sleep(10);
            clip.close();
        } catch (Exception e) {
            System.out.println("Error playing audio: " + e.getMessage());
        }
    }

    private static void append(int start, int end) {
        if (activeFileData == null) {
            System.out.println("No file loaded.");
            return;
        }
        try {
            File output = new File("/tmp/VAD-Analysis.txt");
            try (PrintWriter writer = new PrintWriter(new FileOutputStream(output, true))) {
                for (int i = start; i <= end; i++) {
                    byte b = (byte) activeFileData[i];
                    int pcm = G711Codec.decodeByte(b);
                    float normalized = G711Codec.toNormalizedPCM(b);

                    byte linear = G711Codec.toLinearByte(b);
                    int pcmLinear = G711Codec.decodeByte(linear);
                    float normLinear = G711Codec.toNormalizedPCM(linear);
                    int seconds = (int) i/50;
                    writer.println(activeFileName + "," + i + "," + seconds + ","
                            + b + "," + pcm + "," + normalized + ","
                            + linear + "," + pcmLinear + "," + normLinear);
                }
            }
            System.out.println("Data appended to /tmp/VAD-Analysis.txt");
        } catch (IOException e) {
            System.out.println("Error writing to file: " + e.getMessage());
        }
    }

    public static void header() {
        String header = "filename,seqNum,timestamp,g711,decoded,normalized,linear,decodedLinear,normLinear";
        File output = new File("/tmp/VAD-Analysis.txt");
        try (PrintWriter writer = new PrintWriter(new FileOutputStream(output, true))) {
            writer.println(header);
            System.out.println("header appended to /tmp/VAD-Analysis.txt");
        } catch (IOException e) {
            System.out.println("Error writing to file: " + e.getMessage());
        }
    }
}

======

package analyzer;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class FFTAnalyzer {
    private static final int SAMPLING_RATE = 8000;             // sampling rate in Hz
    private static final float SAMPLES_PER_SECOND = 50.0f;    // conversion factor from samples to time in seconds
    private final Map<String, byte[]> g711Cache = new HashMap<>();
    private final List<TranscriptionWindowWithFFT> transcriptionWindowsWithFFT = new ArrayList<>();

    public static void main(String[] args) throws IOException {
        String transcriptionWindowsInputFilename = "/tmp/vad/formatted-analysis2.txt";
        String g711InputFileRootDirectory = "/asr-data/rod-calls/";
        String outputRoot = "/tmp/vad/";
        String fftAnalysisOutputFilename = outputRoot + "fft-analysis.txt";
        String cosineSimilarityOutputFilename = outputRoot + "cosine-similarities.txt";

        int binSizeHz = 100;                 // bin size in Hz for frequency binning
        String byteRepresentation = "linear"; // or "nonLinear" for non-linear byte decoding
        cosineSimilarityOutputFilename = createBinningFilename(cosineSimilarityOutputFilename, binSizeHz, byteRepresentation);
        performFFTAnalysis(transcriptionWindowsInputFilename, g711InputFileRootDirectory, fftAnalysisOutputFilename, cosineSimilarityOutputFilename, binSizeHz);
    }

    private static void performFFTAnalysis(String transcriptionWindowsInputFilename, String g711InputFileRootDirectory, String fftAnalysisOutputFilename, String cosineSimilarityOutputFilename, int binSizeHz) throws java.io.IOException {
        FFTAnalyzer analyzer = new FFTAnalyzer();
        analyzer.createTranscriptionWindowWithFFT(transcriptionWindowsInputFilename, g711InputFileRootDirectory);
        analyzer.writeTranscriptionWindowToOutputFile(fftAnalysisOutputFilename, analyzer.getTranscriptionWindowsWithFFT(), SAMPLES_PER_SECOND);

        java.util.List<analyzer.CosineSimilarityProcessor> cosineSimilarityTable = analyzer.createCosineSimilarityTable(analyzer.getTranscriptionWindowsWithFFT(), SAMPLING_RATE, binSizeHz);
        analyzer.writeCosineSimilarityTableToFile(cosineSimilarityTable, cosineSimilarityOutputFilename);
    }

    private byte[] readAllBytes(String filePath) {
        try (InputStream inputStream = Files.newInputStream(Paths.get(filePath))) {
            return G711Codec.readAllBytes(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    public void createTranscriptionWindowWithFFT(String transcriptionWindowsInputFilename, String g711InputFileRoot) throws IOException {
        List<TranscriptionWindow> transcriptionWindowRecords = ingestTranscriptionWindowDataFromInputFile(transcriptionWindowsInputFilename);
        for (TranscriptionWindow record : transcriptionWindowRecords) {
            String filePath = g711InputFileRoot + record.getFilename() + ".raw";
            byte[] allG711Bytes = g711Cache.computeIfAbsent(filePath, this::readAllBytes);
            if (allG711Bytes == null) {
                System.out.println("Failed to load G711 data for file: " + filePath);
                continue;
            }
            int startIdx = record.getStart() - 1;
            int endIdx = record.getEnd() - 1;
            if (startIdx < 0 || endIdx >= allG711Bytes.length || startIdx > endIdx) {
                System.out.println("Invalid start or end indices for file: " + filePath);
                continue;
            }
            byte[] bytesBetweenStartAndEnd = new byte[endIdx - startIdx + 1];
            System.arraycopy(allG711Bytes, startIdx, bytesBetweenStartAndEnd, 0, bytesBetweenStartAndEnd.length);
            //float[] floatsBetweenStartAndEnd = G711Codec.g711ByteArrayToNormalizedPCM(bytesBetweenStartAndEnd);
            float[] floatsBetweenStartAndEnd = G711Codec.g711ByteArrayToNormalizedLinearPCM(bytesBetweenStartAndEnd);
            float[] fftResult = FFTProcessor.getFFT(floatsBetweenStartAndEnd);
            float averageEnergy = FFTProcessor.calculateFrameEnergy(fftResult);
            transcriptionWindowsWithFFT.add(new TranscriptionWindowWithFFT(record, fftResult, averageEnergy));
        }
    }

    private List<TranscriptionWindow> ingestTranscriptionWindowDataFromInputFile(String path) throws IOException {
        return Files.lines(Paths.get(path))
                .skip(1)
                .map(line -> {
                    String[] parts = line.split("\\|");
                    return new TranscriptionWindow(
                            parts[0].trim(),                        // filename
                            Integer.parseInt(parts[2].trim()),      // seqNum
                            Integer.parseInt(parts[3].trim()),      // start
                            Integer.parseInt(parts[4].trim()),      // end
                            parts[5].trim(),                        // transcript
                            Integer.parseInt(parts[6].trim()),      // tokens
                            Integer.parseInt(parts[7].trim()),      // samples
                            Float.parseFloat(parts[8].trim())       // samplesPerToken
                    );
                })
                .collect(Collectors.toList());
    }

    public void writeTranscriptionWindowToOutputFile(String outputFilename, List<TranscriptionWindowWithFFT> transcriptionWindowsWithFFT, float samplesPerSecond) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFilename))) {
            for (TranscriptionWindowWithFFT twWithFFT : transcriptionWindowsWithFFT) {
                TranscriptionWindow record = twWithFFT.getTranscriptionWindow();
                float[] fft = twWithFFT.getFft();

                writer.write(String.format("%s | %d | %d | [%.3f, %.3f] | %d | %.3f | %s%n",
                        record.getFilename(), record.getStart(), record.getEnd(),
                        record.getStart() / samplesPerSecond, record.getEnd() / samplesPerSecond, record.getSeqNum(), twWithFFT.getAvgEnergy(), record.getTranscript()));

                for (float fftValue : fft) {
                    writer.write(fftValue + System.lineSeparator());
                }
            }
        }
    }

    public List<TranscriptionWindowWithFFT> getTranscriptionWindowsWithFFT() {
        return transcriptionWindowsWithFFT;
    }

    public List<CosineSimilarityProcessor> createCosineSimilarityTable(List<TranscriptionWindowWithFFT> transcriptionWindowsWithFFT, int samplingRate, int binSizeHz) {
        List<CosineSimilarityProcessor> cosineSimilarityTable = new ArrayList<>();
        for (int i = 0; i < transcriptionWindowsWithFFT.size(); i++) {
            TranscriptionWindowWithFFT tw1 = transcriptionWindowsWithFFT.get(i);
            String id1 = tw1.getTranscriptionWindow().getFFTIdentifier();
            float[] fft1 = binFrequenciesVersusCount(tw1.getFft(), samplingRate, binSizeHz);

            for (int j = i + 1; j < transcriptionWindowsWithFFT.size(); j++) {
                TranscriptionWindowWithFFT tw2 = transcriptionWindowsWithFFT.get(j);
                String id2 = tw2.getTranscriptionWindow().getFFTIdentifier();
                float[] fft2 = binFrequenciesVersusCount(tw2.getFft(), samplingRate, binSizeHz);

                CosineSimilarityProcessor record = CosineSimilarityProcessor.fromFFT(id1, fft1, id2, fft2);
                cosineSimilarityTable.add(record);
            }
        }
        return cosineSimilarityTable;
    }

    public float[] binFrequenciesVersusCount(float[] fft, int samplingRate, int binSizeHz) {
        int numBins = (samplingRate/2) / binSizeHz;
        float[] binnedFFT = new float[numBins];
        int fftLength = fft.length * 2;
        float frequencyPerBin = samplingRate / (float) fftLength;
        for (int i = 0; i < fft.length; i++) {
            float frequency = i * frequencyPerBin;
            int binIndex = (int) (frequency / binSizeHz);
            if (binIndex < numBins) {
                binnedFFT[binIndex] += fft[i];
            }
        }
        for (int i = 0; i < binnedFFT.length; i++) {
            int count = Math.max(1, Math.round(binSizeHz / frequencyPerBin));
            binnedFFT[i] /= count;
        }
        return binnedFFT;
    }

    public void writeCosineSimilarityTableToFile(List<CosineSimilarityProcessor> cosineSimilarityTable, String outputFilename) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFilename))) {
            for (CosineSimilarityProcessor record : cosineSimilarityTable) {
                writer.write(String.format("%s, %s, %.3f%n", record.getId1(), record.getId2(), record.getCosineSimilarity()));
            }
        }
    }

    public static String createBinningFilename(String theFilename, int binSize, String decodeRepresentation) {
        int dotIndex = theFilename.lastIndexOf('.');
        if (dotIndex == -1) {
            return theFilename + "_" + binSize + "_" + decodeRepresentation;
        }
        String baseName = theFilename.substring(0, dotIndex);
        String extension = theFilename.substring(dotIndex);
        return baseName + "_" + binSize + "_" + decodeRepresentation + extension;
    }
 }