import java.util.ArrayList;
import java.util.List;
import org.apache.commons.math3.complex.Complex;
import org.apache.commons.math3.transform.DftNormalization;
import org.apache.commons.math3.transform.FastFourierTransformer;
import org.apache.commons.math3.transform.TransformType;

public class SpanDetector {
    private int sr;
    private int currIdx;
    private Candidate currCandidate;
    private List<Span> spans;
    private double backgroundEnergyTimeout;
    private boolean backgroundEnergyInitialized;
    private double backgroundEnergy;
    private double dbOffset;
    private double minSoFar;

    public SpanDetector(int sr) {
        this.sr = sr;
        this.currIdx = 0;
        this.currCandidate = null;
        this.spans = new ArrayList<>();
        this.backgroundEnergyTimeout = 2.0;
        this.backgroundEnergyInitialized = false;
        this.backgroundEnergy = 0.0;
        this.dbOffset = 2.5;
        this.minSoFar = Double.POSITIVE_INFINITY;
    }

    public List<Span> addToStream(float[] audio, String speaker) {
        int nSamples = audio.length;
        double secondsPerFrame = 20e-3;
        int samplesPerFrame = (int) (secondsPerFrame * sr);
        List<Span> spans = new ArrayList<>();

        for (int i = 0; i < nSamples - 1; i += samplesPerFrame) {
            int start = i + currIdx;
            int end = start + samplesPerFrame;
            float[] audioB = new float[samplesPerFrame];
            System.arraycopy(audio, i, audioB, 0, samplesPerFrame);

            double frameEnergy = calculateFrameEnergy(audioB);
            if (frameEnergy < minSoFar) {
                minSoFar = frameEnergy;
            }

            if ((double) currIdx / sr < backgroundEnergyTimeout) {
                if (!backgroundEnergyInitialized) {
                    backgroundEnergy = frameEnergy;
                    backgroundEnergyInitialized = true;
                } else {
                    backgroundEnergy += (frameEnergy - backgroundEnergy) / (end / samplesPerFrame);
                }
                continue;
            }

            double offset = Math.log10(frameEnergy / backgroundEnergy);
            if (offset < 0) {
                backgroundEnergy = (0.1 * backgroundEnergy + 0.9 * frameEnergy);
                continue;
            } else if (Math.log10(frameEnergy / backgroundEnergy) > dbOffset) {
                if (offset > 5) {
                    backgroundEnergy = (0.98 * backgroundEnergy + 0.02 * frameEnergy);
                } else {
                    backgroundEnergy = (0.90 * backgroundEnergy + 0.10 * minSoFar);
                }
                if (currCandidate == null) {
                    currCandidate = new Candidate(start, frameEnergy);
                }
                Span span = new Span(currCandidate.getStartIdx(), end, currCandidate.getStartDb(), frameEnergy,
                        currCandidate.getNumVoiceChunks(), currCandidate.getNumNonVoiceChunks(), speaker);
                spans.add(span);
                this.spans.add(span);

                currCandidate = null;
            }
        }
        currIdx += nSamples;
        return spans;
    }

    private double calculateFrameEnergy(float[] audioB) {
        double[] fftResult = getFFT(audioB);
        double sumSquares = 0.0;
        for (double v : fftResult) {
            sumSquares += v * v;
        }
        return sumSquares / fftResult.length;
    }

    private double[] getFFT(float[] audio) {
        int N = audio.length;
        double[] windowedAudio = new double[N];
        for (int i = 0; i < N; i++) {
            windowedAudio[i] = audio[i] * (0.54 - 0.46 * Math.cos(2 * Math.PI * i / (N - 1)));
        }
        FastFourierTransformer transformer = new FastFourierTransformer(DftNormalization.STANDARD);
        Complex[] complexResult = transformer.transform(windowedAudio, TransformType.FORWARD);
        double[] result = new double[complexResult.length];
        for (int i = 0; i < complexResult.length; i++) {
            result[i] = complexResult[i].abs();
        }
        return result;
    }

    public static void main(String[] args) {
        SpanDetector detector = new SpanDetector(16000);
        float[] audio = { /* some audio data */ };
        String speaker = "speaker1";
        List<Span> spans = detector.addToStream(audio, speaker);
        // Process spans
    }
}