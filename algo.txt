package analyzer;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class FFTAnalyzer {

    private final Map<String, byte[]> g711Cache = new HashMap<>();
    private final List<TranscriptionWindowWithFFT> transcriptionWindowsWithFFT = new ArrayList<>();

    public static void main(String[] args) throws IOException {
        String transcriptionWindowsInputFilename = "/tmp/vad/formatted-analysis2.txt";
        String fftAnalysisOutputFilename = "/tmp/vad/fft-analysis.txt";
        String g711InputFileRootDirectory = "/asr-data/rod-calls/";
        String cosineDistanceOutputFilename = "/tmp/vad/cosine-distances.txt";

        int samplingRate = 8000;             // Defined sampling rate in Hz
        int binSizeHz = 100;                 // Defined bin size in Hz for frequency binning
        float SAMPLES_PER_SECOND = 50.0f;    // Defined samples per second for time conversion

        FFTAnalyzer analyzer = new FFTAnalyzer();
        analyzer.createTranscriptionWindowWithFFT(transcriptionWindowsInputFilename, g711InputFileRootDirectory);
        analyzer.writeTranscriptionWindowToOutputFile(fftAnalysisOutputFilename, analyzer.getTranscriptionWindowsWithFFT(), SAMPLES_PER_SECOND);

        List<CosineDistanceProcessor> cosineDistanceTable = analyzer.createCosineDistanceTable(analyzer.getTranscriptionWindowsWithFFT(), samplingRate, binSizeHz);
        analyzer.writeCosineDistanceTableToFile(cosineDistanceTable, cosineDistanceOutputFilename);
    }

    private byte[] readAllBytes(String filePath) {
        try (InputStream inputStream = new FileInputStream(filePath)) {
            return G711Codec.readAllBytes(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    public void createTranscriptionWindowWithFFT(String transcriptionWindowsInputFilename, String g711InputFileRoot) throws IOException {
        List<TranscriptionWindow> transcriptionWindowRecords = ingestTranscriptionWindowDataFromInputFile(transcriptionWindowsInputFilename);
        for (TranscriptionWindow record : transcriptionWindowRecords) {
            String filePath = g711InputFileRoot + record.getFilename() + ".raw";
            byte[] allG711Bytes = g711Cache.computeIfAbsent(filePath, this::readAllBytes);
            if (allG711Bytes == null) {
                System.out.println("Failed to load G711 data for file: " + filePath);
                continue;
            }
            int startIdx = record.getStart() - 1;
            int endIdx = record.getEnd() - 1;
            if (startIdx < 0 || endIdx >= allG711Bytes.length || startIdx > endIdx) {
                System.out.println("Invalid start or end indices for file: " + filePath);
                continue;
            }
            byte[] bytesBetweenStartAndEnd = new byte[endIdx - startIdx + 1];
            System.arraycopy(allG711Bytes, startIdx, bytesBetweenStartAndEnd, 0, bytesBetweenStartAndEnd.length);
            float[] floatsBetweenStartAndEnd = G711Codec.g711ByteArrayToNormalizedPCM(bytesBetweenStartAndEnd);
            float[] fftResult = FFTProcessor.getFFT(floatsBetweenStartAndEnd);
            transcriptionWindowsWithFFT.add(new TranscriptionWindowWithFFT(record, fftResult));
        }
    }

    private List<TranscriptionWindow> ingestTranscriptionWindowDataFromInputFile(String path) throws IOException {
        return Files.lines(Paths.get(path))
                .skip(1)
                .map(line -> {
                    String[] parts = line.split("\\|");
                    return new TranscriptionWindow(
                            parts[0].trim(),                        // filename
                            Integer.parseInt(parts[2].trim()),      // seqNum
                            Integer.parseInt(parts[3].trim()),      // start
                            Integer.parseInt(parts[4].trim()),      // end
                            parts[5].trim(),                        // transcript
                            Integer.parseInt(parts[6].trim()),      // tokens
                            Integer.parseInt(parts[7].trim()),      // samples
                            Float.parseFloat(parts[8].trim())       // samplesPerToken
                    );
                })
                .collect(Collectors.toList());
    }

    public void writeTranscriptionWindowToOutputFile(String outputFilename, List<TranscriptionWindowWithFFT> transcriptionWindowsWithFFT, float samplesPerSecond) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFilename))) {
            for (TranscriptionWindowWithFFT twWithFFT : transcriptionWindowsWithFFT) {
                TranscriptionWindow record = twWithFFT.getTranscriptionWindow();
                float[] fft = twWithFFT.getFft();

                writer.write(String.format("%s | %d | %d | [%.3f, %.3f] | %s%n",
                        record.getFilename(), record.getStart(), record.getEnd(),
                        record.getStart() / samplesPerSecond, record.getEnd() / samplesPerSecond, record.getTranscript()));

                for (float fftValue : fft) {
                    writer.write(fftValue + System.lineSeparator());
                }
            }
        }
    }

    public List<TranscriptionWindowWithFFT> getTranscriptionWindowsWithFFT() {
        return transcriptionWindowsWithFFT;
    }

    public List<CosineDistanceProcessor> createCosineDistanceTable(List<TranscriptionWindowWithFFT> transcriptionWindowsWithFFT, int samplingRate, int binSizeHz) {
        List<CosineDistanceProcessor> cosineDistanceTable = new ArrayList<>();
        for (int i = 0; i < transcriptionWindowsWithFFT.size(); i++) {
            TranscriptionWindowWithFFT tw1 = transcriptionWindowsWithFFT.get(i);
            String id1 = tw1.getTranscriptionWindow().getFFTIdentifier();
            float[] fft1 = binFrequenciesVersusCount(tw1.getFft(), samplingRate, binSizeHz);

            for (int j = i + 1; j < transcriptionWindowsWithFFT.size(); j++) {
                TranscriptionWindowWithFFT tw2 = transcriptionWindowsWithFFT.get(j);
                String id2 = tw2.getTranscriptionWindow().getFFTIdentifier();
                float[] fft2 = binFrequenciesVersusCount(tw2.getFft(), samplingRate, binSizeHz);

                CosineDistanceProcessor record = CosineDistanceProcessor.fromFFT(id1, fft1, id2, fft2);
                cosineDistanceTable.add(record);
            }
        }
        return cosineDistanceTable;
    }

    public float[] binFrequenciesVersusCount(float[] fft, int samplingRate, int binSizeHz) {
        int numBins = (samplingRate/2) / binSizeHz;
        float[] binnedFFT = new float[numBins];
        int fftLength = fft.length * 2;
        float frequencyPerBin = samplingRate / (float) fftLength;
        for (int i = 0; i < fft.length; i++) {
            float frequency = i * frequencyPerBin;
            int binIndex = (int) (frequency / binSizeHz);
            if (binIndex < numBins) {
                binnedFFT[binIndex] += fft[i];
            }
        }
        for (int i = 0; i < binnedFFT.length; i++) {
            int count = Math.max(1, Math.round(binSizeHz / frequencyPerBin));
            binnedFFT[i] /= count;
        }
        return binnedFFT;
    }

    public void writeCosineDistanceTableToFile(List<CosineDistanceProcessor> cosineDistanceTable, String outputFilename) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFilename))) {
            for (CosineDistanceProcessor record : cosineDistanceTable) {
                writer.write(String.format("%s, %s, %.3f%n", record.getId1(), record.getId2(), record.getCosineDistance()));
            }
        }
    }
 }
 
 ==========================================
 
 package analyzer;

public class TranscriptionWindowWithFFT {
    private final TranscriptionWindow transcriptionWindow;
    private final float[] fft;

    public TranscriptionWindowWithFFT(TranscriptionWindow transcriptionWindow, float[] fft) {
        this.transcriptionWindow = transcriptionWindow;
        this.fft = fft;
    }

    public TranscriptionWindow getTranscriptionWindow() {
        return transcriptionWindow;
    }

    public float[] getFft() {
        return fft;
    }
}

============================================

package analyzer;

public class TranscriptionWindow {
    private final String filename;
    private final int seqNum;
    private final int start;
    private final int end;
    private final String transcript;
    private final int tokens;
    private final int samples;
    private final float samplesPerToken;  // Updated to float

    public TranscriptionWindow(String filename, int seqNum, int start, int end, String transcript, int tokens, int samples, float samplesPerToken) {
        this.filename = filename;
        this.seqNum = seqNum;
        this.start = start;
        this.end = end;
        this.transcript = transcript;
        this.tokens = tokens;
        this.samples = samples;
        this.samplesPerToken = samplesPerToken;
    }

    public String getFilename() {
        return filename;
    }

    public int getSeqNum() {
        return seqNum;
    }

    public int getStart() {
        return start;
    }

    public int getEnd() {
        return end;
    }

    public String getTranscript() {
        return transcript;
    }

    public int getTokens() {
        return tokens;
    }

    public int getSamples() {
        return samples;
    }

    public float getSamplesPerToken() {
        return samplesPerToken;
    }

    public String getFFTIdentifier() {
        String[] sections = filename.split("_");
        if (sections.length < 2) {
            throw new IllegalArgumentException("Incorrect filename format: " + filename);
        }
        String digitsSection2 = sections[1].replaceAll("[^0-9]", "");
        return digitsSection2 + "_" + seqNum;
    }
}

==================================

package analyzer;

public class CosineDistanceProcessor {
    private final String id1;
    private final String id2;
    private final double cosineDistance;

    private CosineDistanceProcessor(String id1, String id2, double cosineDistance) {
        this.id1 = id1;
        this.id2 = id2;
        this.cosineDistance = cosineDistance;
    }

    public static CosineDistanceProcessor fromFFT(String id1, float[] fft1, String id2, float[] fft2) {
        double cosineDistance = calculateCosineDistance(fft1, fft2);
        return new CosineDistanceProcessor(id1, id2, cosineDistance);
    }

    private static double calculateCosineDistance(float[] fft1, float[] fft2) {
        double dotProduct = 0.0;
        double magnitude1 = 0.0;
        double magnitude2 = 0.0;
        int length = Math.min(fft1.length, fft2.length);
        for (int i = 0; i < length; i++) {
            dotProduct += fft1[i] * fft2[i];
            magnitude1 += fft1[i] * fft1[i];
            magnitude2 += fft2[i] * fft2[i];
        }
        magnitude1 = Math.sqrt(magnitude1);
        magnitude2 = Math.sqrt(magnitude2);
        if (magnitude1 == 0 || magnitude2 == 0) {
            return 0;
        }
        return dotProduct / (magnitude1 * magnitude2);
    }

    public String getId1() {
        return id1;
    }

    public String getId2() {
        return id2;
    }

    public double getCosineDistance() {
        return cosineDistance;
    }
}

===================================