import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

public abstract class DataToFileAppender<T> {

    private static String defaultRoot = "c:/data/root/";

    public void appendToFile(String pathRoot, String name, String port, T data, String header) {
        if (pathRoot == null) {
            pathRoot = defaultRoot;
        }
        String filePath = pathRoot + name + "_" + port + ".txt";
        File file = new File(filePath);
        boolean fileExists = file.exists();

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, true))) {
            if (!fileExists && header != null) {
                writer.write(header);
                writer.newLine();
            }
            String dataString = convertDataToString(data);
            writer.write(dataString);
            writer.newLine();
        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    protected abstract String convertDataToString(T data);
}

public class StringToFileAppender extends DataToFileAppender<String> {

    @Override
    protected String convertDataToString(String data) {
        return data;
    }

    public static void main(String[] args) {
        StringToFileAppender appender = new StringToFileAppender();
        String pathRoot = "j:/downloads/";
        String name = "string_data";
        String port = "55674";
        String data = "This is a sample string to append to the file.";
        String header = "Header Line";

        for (int k = 0; k < 5; k++) {
            appender.appendToFile(pathRoot, name, port, data, header);
        }
    }
}

import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class ByteArrayToFileAppender extends DataToFileAppender<byte[]> {

    @Override
    protected String convertDataToString(byte[] data) {
        return IntStream.range(0, data.length)
                .mapToObj(i -> Byte.toString(data[i]))
                .collect(Collectors.joining(","));
    }

    public static void main(String[] args) {
        ByteArrayToFileAppender appender = new ByteArrayToFileAppender();
        String pathRoot = "j:/downloads/";
        String name = "byte_array";
        String port = "8080";
        byte[] data = {0, 127, -128, -1, 10, 20, 30, 40, -50, -60, -70, -80};
        String header = null;

        appender.appendToFile(pathRoot, name, port, data, header);
    }
}

import net.sf.fmj.media.rtp.util.RTPPacket;
import org.springframework.integration.core.GenericSelector;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Service
public class AudioMessageFilter implements GenericSelector<Message<?>> {

    @Override
    public boolean accept(Message<?> message) {
        MessageBuilder<?> messageBuilder = MessageBuilder.fromMessage(message);

        if (!message.getHeaders().containsKey("VAD_REJECTED")) {
            messageBuilder.setHeader("VAD_REJECTED", new ArrayList<Integer>());
        }
        if (!message.getHeaders().containsKey("VAD_ACCEPTED")) {
            messageBuilder.setHeader("VAD_ACCEPTED", new ArrayList<Integer>());
        }

        message = messageBuilder.build();

        RTPPacket rtpPacket = (RTPPacket) message.getPayload();
        int sequenceNumber = rtpPacket.seqnum;
        byte[] rtpData = rtpPacket.data;

        Set<Byte> dataSet = new HashSet<>();
        for (byte b : rtpData) {
            dataSet.add(b);
        }

        if (dataSet.size() == 2 && dataSet.contains((byte) 126) && dataSet.contains((byte) -1)) {
            List<Integer> vadRejected = (List<Integer>) message.getHeaders().get("VAD_REJECTED");
            vadRejected.add(sequenceNumber);
            return false;
        } else {
            List<Integer> vadAccepted = (List<Integer>) message.getHeaders().get("VAD_ACCEPTED");
            vadAccepted.add(sequenceNumber);
            return true;
        }
    }
}


