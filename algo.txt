import pandas as pd
from openpyxl import Workbook
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.styles import Font
import re
import os

def extract_raw_data(raw_text, filename):
    """Extracts 'Seq Num' and 'Transcription' values from a _raw column string.
       Prints a message if no patterns match."""
    # Define both sets of patterns for Seq Num and Transcription
    patterns = [
        (r"Seq Num: (\d{1,5})", r"Transcript: (.*?), stopTime"),
        (r"Sequence Number: (\d{1,5})", r"Transcription: (.*)$")
    ]
    
    # Attempt to match one set of patterns
    for seq_pattern, transcription_pattern in patterns:
        seq_num_match = re.search(seq_pattern, raw_text)
        transcription_match = re.search(transcription_pattern, raw_text)
        
        # If both patterns in a set match, extract and return values for that set
        if seq_num_match and transcription_match:
            seq_num = int(seq_num_match.group(1))
            transcription = transcription_match.group(1)
            return seq_num, transcription

    # If no patterns matched, print a message with the filename
    print(f"No matching patterns found in '{filename}' for text: {raw_text}")
    return None, None

def transform_csv_to_excel(input_dir, output_dir, output_cols):
    # Parse the comma-separated column names and strip any extra whitespace
    columns_to_extract = [col.strip() for col in output_cols.split(",")]

    # Ensure output directory exists
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        
    # Process each CSV file in the input directory
    for filename in os.listdir(input_dir):
        if filename.endswith(".csv"):
            input_csv_path = os.path.join(input_dir, filename)
            output_excel_path = os.path.join(output_dir, filename.replace(".csv", ".xlsx"))
            worksheet_name = filename.split('.')[0]  # Get filename without extension for worksheet name

            # Load CSV
            df = pd.read_csv(input_csv_path)

            # Special handling if _raw is the only column specified
            if "_raw" in columns_to_extract and len(columns_to_extract) == 1:
                # Only _raw column is requested, so we just process this one
                seq_nums = []
                transcriptions = []

                for raw_text in df["_raw"]:
                    seq_num, transcription = extract_raw_data(raw_text, filename)
                    seq_nums.append(seq_num)
                    transcriptions.append(transcription)
                
                # Create a new DataFrame with only Seq Num and Transcription columns
                filtered_df = pd.DataFrame({"Seq Num": seq_nums, "Transcription": transcriptions})

                # Remove rows where both Seq Num and Transcription are empty
                filtered_df.dropna(subset=["Seq Num", "Transcription"], how="all", inplace=True)

                # Sort by Seq Num in ascending order
                filtered_df.sort_values(by="Seq Num", ascending=True, inplace=True)

            elif set(columns_to_extract).issubset(df.columns) or "_raw" in columns_to_extract:
                # Standard case where we have other specified columns, handle _raw if present
                if "_raw" in columns_to_extract:
                    seq_nums = []
                    transcriptions = []

                    for raw_text in df["_raw"]:
                        seq_num, transcription = extract_raw_data(raw_text, filename)
                        seq_nums.append(seq_num)
                        transcriptions.append(transcription)

                    # Add extracted data to the DataFrame
                    df["Seq Num"] = seq_nums
                    df["Transcription"] = transcriptions

                    # Remove _raw from columns and add "Seq Num" and "Transcription"
                    columns_to_extract.remove("_raw")
                    columns_to_extract.extend(["Seq Num", "Transcription"])

                # Filter columns based on specified output columns
                filtered_df = df[columns_to_extract]

            else:
                # If required columns are missing, skip this file
                print(f"Skipping '{input_csv_path}': Required columns not present.")
                continue

            # Write to Excel with OpenPyXL to apply formatting
            wb = Workbook()
            ws = wb.active
            ws.title = worksheet_name

            # Append rows to worksheet
            for row in dataframe_to_rows(filtered_df, index=False, header=True):
                ws.append(row)

            # Set column widths if specific columns are used, otherwise default width
            column_widths = {
                "Branch": 11,
                "Intent": 37,
                "Utterance": 110,
                "Seq Num": 9,
                "Transcription": 65
            }
            for i, col_name in enumerate(filtered_df.columns, start=1):
                col_letter = ws.cell(row=1, column=i).column_letter
                ws.column_dimensions[col_letter].width = column_widths.get(col_name, 15)  # Default width 15 if not specified

            # Set font to Arial 8 for each cell in the worksheet
            font_style = Font(name="Arial", size=8)
            for row in ws.iter_rows():
                for cell in row:
                    cell.font = font_style

            # Freeze the top row
            ws.freeze_panes = "A2"

            # Add filters to each column
            ws.auto_filter.ref = ws.dimensions

            # Save to Excel file, overwriting if it already exists
            wb.save(output_excel_path)

            # Print confirmation message
            print(f"Filename '{output_excel_path}' processed")

# Example usage:
inputDir = "/my/root/dir"
outputDir = "/my/root/dir"
outputCols = "_raw"  # Only _raw column, for Seq Num and Transcription extraction
transform_csv_to_excel(inputDir, outputDir, outputCols)