package analyzer;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class FFTAnalyzer {
    private static final int SAMPLING_RATE = 8000;             // sampling rate in Hz
    private static final float SAMPLES_PER_SECOND = 50.0f;    // conversion factor from samples to time in seconds
    private final Map<String, byte[]> g711Cache = new HashMap<>();
    private final List<TranscriptionWindowWithFFT> transcriptionWindowsWithFFT = new ArrayList<>();

    public static void main(String[] args) throws IOException {
        String transcriptionWindowsInputFilename = "/tmp/vad/formatted-analysis2.txt";
        String g711InputFileRootDirectory = "/asr-data/rod-calls/";
        String outputRoot = "/tmp/vad/";
        String fftAnalysisOutputFilename = outputRoot + "fft-analysis.txt";
        String cosineSimilarityOutputFilename = outputRoot + "cosine-similarities.txt";

        int binSizeHz = 100;                 // bin size in Hz for frequency binning
        boolean decodeIsLinear = true;       // false for non-linear byte decoding
        cosineSimilarityOutputFilename = createBinningFilename(cosineSimilarityOutputFilename, binSizeHz, decodeIsLinear);
        performFFTAnalysis(transcriptionWindowsInputFilename, g711InputFileRootDirectory, fftAnalysisOutputFilename, cosineSimilarityOutputFilename, binSizeHz, decodeIsLinear);
    }

    private static void performFFTAnalysis(String transcriptionWindowsInputFilename, String g711InputFileRootDirectory, String fftAnalysisOutputFilename, String cosineSimilarityOutputFilename, int binSizeHz, boolean decodeIsLinear) throws java.io.IOException {
        FFTAnalyzer analyzer = new FFTAnalyzer();
        analyzer.createTranscriptionWindowWithFFT(transcriptionWindowsInputFilename, g711InputFileRootDirectory, decodeIsLinear);
        analyzer.writeTranscriptionWindowToOutputFile(fftAnalysisOutputFilename, analyzer.getTranscriptionWindowsWithFFT(), SAMPLES_PER_SECOND);

        java.util.List<analyzer.CosineSimilarityProcessor> cosineSimilarityTable = analyzer.createCosineSimilarityTable(analyzer.getTranscriptionWindowsWithFFT(), SAMPLING_RATE, binSizeHz);
        analyzer.writeCosineSimilarityTableToFile(cosineSimilarityTable, cosineSimilarityOutputFilename);
    }

    private byte[] readAllBytes(String filePath) {
        try (InputStream inputStream = Files.newInputStream(Paths.get(filePath))) {
            return G711Codec.readAllBytes(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    public void createTranscriptionWindowWithFFT(String transcriptionWindowsInputFilename, String g711InputFileRoot, boolean decodeIsLinear) throws IOException {
        List<TranscriptionWindow> transcriptionWindowRecords = ingestTranscriptionWindowDataFromInputFile(transcriptionWindowsInputFilename);
        for (TranscriptionWindow record : transcriptionWindowRecords) {
            String filePath = g711InputFileRoot + record.getFilename() + ".raw";
            byte[] allG711Bytes = g711Cache.computeIfAbsent(filePath, this::readAllBytes);
            if (allG711Bytes == null) {
                System.out.println("Failed to load G711 data for file: " + filePath);
                continue;
            }
            int startIdx = record.getStart() - 1;
            int endIdx = record.getEnd() - 1;
            if (startIdx < 0 || endIdx >= allG711Bytes.length || startIdx > endIdx) {
                System.out.println("Invalid start or end indices for file: " + filePath);
                continue;
            }
            byte[] bytesBetweenStartAndEnd = new byte[endIdx - startIdx + 1];
            System.arraycopy(allG711Bytes, startIdx, bytesBetweenStartAndEnd, 0, bytesBetweenStartAndEnd.length);
            float[] floatsBetweenStartAndEnd;
            if (decodeIsLinear) {
                floatsBetweenStartAndEnd = G711Codec.g711ByteArrayToNormalizedLinearPCM(bytesBetweenStartAndEnd);
            } else {
                floatsBetweenStartAndEnd = G711Codec.g711ByteArrayToNormalizedPCM(bytesBetweenStartAndEnd);
            }
            float[] fftResult = FFTProcessor.getFFT(floatsBetweenStartAndEnd);
            float averageEnergy = FFTProcessor.calculateFrameEnergy(fftResult);
            transcriptionWindowsWithFFT.add(new TranscriptionWindowWithFFT(record, fftResult, averageEnergy));
        }
    }

    private List<TranscriptionWindow> ingestTranscriptionWindowDataFromInputFile(String path) throws IOException {
        return Files.lines(Paths.get(path))
                .skip(1)
                .map(line -> {
                    String[] parts = line.split("\\|");
                    return new TranscriptionWindow(
                            parts[0].trim(),                        // filename
                            Integer.parseInt(parts[2].trim()),      // seqNum
                            Integer.parseInt(parts[3].trim()),      // start
                            Integer.parseInt(parts[4].trim()),      // end
                            parts[5].trim(),                        // transcript
                            Integer.parseInt(parts[6].trim()),      // tokens
                            Integer.parseInt(parts[7].trim()),      // samples
                            Float.parseFloat(parts[8].trim())       // samplesPerToken
                    );
                })
                .collect(Collectors.toList());
    }

    public void writeTranscriptionWindowToOutputFile(String outputFilename, List<TranscriptionWindowWithFFT> transcriptionWindowsWithFFT, float samplesPerSecond) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFilename))) {
            for (TranscriptionWindowWithFFT twWithFFT : transcriptionWindowsWithFFT) {
                TranscriptionWindow record = twWithFFT.getTranscriptionWindow();
                float[] fft = twWithFFT.getFft();

                writer.write(String.format("%s | %d | %d | [%.3f, %.3f] | %d | %.3f | %s%n",
                        record.getFilename(), record.getStart(), record.getEnd(),
                        record.getStart() / samplesPerSecond, record.getEnd() / samplesPerSecond, record.getSeqNum(), twWithFFT.getAvgEnergy(), record.getTranscript()));

                for (float fftValue : fft) {
                    writer.write(fftValue + System.lineSeparator());
                }
            }
        }
    }

    public List<TranscriptionWindowWithFFT> getTranscriptionWindowsWithFFT() {
        return transcriptionWindowsWithFFT;
    }

    public List<CosineSimilarityProcessor> createCosineSimilarityTable(List<TranscriptionWindowWithFFT> transcriptionWindowsWithFFT, int samplingRate, int binSizeHz) {
        List<CosineSimilarityProcessor> cosineSimilarityTable = new ArrayList<>();
        for (int i = 0; i < transcriptionWindowsWithFFT.size(); i++) {
            TranscriptionWindowWithFFT tw1 = transcriptionWindowsWithFFT.get(i);
            String id1 = tw1.getTranscriptionWindow().getFFTIdentifier();
            float[] fft1 = binFrequenciesVersusCount(tw1.getFft(), samplingRate, binSizeHz);

            for (int j = i + 1; j < transcriptionWindowsWithFFT.size(); j++) {
                TranscriptionWindowWithFFT tw2 = transcriptionWindowsWithFFT.get(j);
                String id2 = tw2.getTranscriptionWindow().getFFTIdentifier();
                float[] fft2 = binFrequenciesVersusCount(tw2.getFft(), samplingRate, binSizeHz);

                CosineSimilarityProcessor record = CosineSimilarityProcessor.fromFFT(id1, fft1, id2, fft2);
                cosineSimilarityTable.add(record);
            }
        }
        return cosineSimilarityTable;
    }

    public float[] binFrequenciesVersusCount(float[] fft, int samplingRate, int binSizeHz) {
        int numBins = (samplingRate/2) / binSizeHz;
        float[] binnedFFT = new float[numBins];
        int fftLength = fft.length * 2;
        float frequencyPerBin = samplingRate / (float) fftLength;
        for (int i = 0; i < fft.length; i++) {
            float frequency = i * frequencyPerBin;
            int binIndex = (int) (frequency / binSizeHz);
            if (binIndex < numBins) {
                binnedFFT[binIndex] += fft[i];
            }
        }
        for (int i = 0; i < binnedFFT.length; i++) {
            int count = Math.max(1, Math.round(binSizeHz / frequencyPerBin));
            binnedFFT[i] /= count;
        }
        return binnedFFT;
    }

    public void writeCosineSimilarityTableToFile(List<CosineSimilarityProcessor> cosineSimilarityTable, String outputFilename) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFilename))) {
            for (CosineSimilarityProcessor record : cosineSimilarityTable) {
                writer.write(String.format("%s, %s, %.3f%n", record.getId1(), record.getId2(), record.getCosineSimilarity()));
            }
        }
    }

    public static String createBinningFilename(String theFilename, int binSize, boolean decodeIsLinear) {
        int dotIndex = theFilename.lastIndexOf('.');
        String decodeRepresentation = decodeIsLinear ? "linear" : "nonlinear";
        if (dotIndex == -1) {
            return theFilename + "_" + binSize + "_" + decodeRepresentation;
        }
        String baseName = theFilename.substring(0, dotIndex);
        String extension = theFilename.substring(dotIndex);
        return baseName + "_" + binSize + "_" + decodeRepresentation + extension;
    }
 }